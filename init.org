#+TITLE: Literate Emacs
#+property: header-args :tangle ./init.el :comments no :results output silent

* Preface
This is my attempt at modularizing my =.emacs.d= directory and preventing eventual /Emacs Bankruptcy/ by exporting my configurations through the [[http://orgmode.org/][org-mode]] [[https://orgmode.org/manual/tangle.html][tangle]] system.

I am still in the progress of figuring out the best structure for this kind document. Scattered around the file you might find a plethora of =TODO=-markings for all different kinds of stuff.

Most of this file has unfortunately been written in a really inconsistent style. This applies to its structure as well as the language used.

These are some of the things that (probably) will need to be fixed at some point:

+ Structure
  + Linebreaks in/after sentences
  + Code blocks
    + Blank lines at beginning/end?
    + Blank lines before/after?
  + Footnotes
  + Uppercase/Downcase in headings
+ Language
  + Inconsistent third/first person
  + Inconsistent formality
  + Active/Passive
    + This does that
    + Do that here
  + Repetition of phrases
  + Strange sentence structure
+ Spelling
  + General spelling mistakes
  + Uppercase/Downcase
    + Lists
    + Package names
    + Application names

Please don't use this on your own machine. Just don't. [fn:dotfiles]


This setup was heavily inspired by [[https://github.com/wasamasa][wasamasa]]s [[https://github.com/wasamasa/dotemacs][dotemacs]] repository.

* Package management
As using Emacs without any extensions[fn:extensions] is pretty undesirable, the ability to easily and quickly load collections of elisp from external sources. However the builtin way of achieving this (package.el + =require=) is wonky at best.

For this reason I choose to leave package.el behind and instead use the new and shiny straight.el in conjunction with use-package, which acts as an improved =require= wrapper.

This subtree also contains some other configurations related to loading external code and package administration.

** straight.el
This package is responsible for correctly setting the load path to various collections of elisp code that live in =.emacs.d/straight=. straight.el ensures absolute configuration reproducibility through its use of a lockfile located in =straight/versions/default.el=. It also allows my own packages to comfortably live inside =straight/repos= as it's various end-user functions allow for interactively managing state changes.

#+begin_src elisp

(setq straight-check-for-modifications
      '(find-when-checking check-on-save))
      
(setq straight-recipe-repositories
      '(org-elpa melpa emacsmirror gnu-elpa-mirror))
      
#+end_src

This package has to be loaded first and using a manual `bootstrap` procedure, because it is the package responsible for loading all other packages. (Chicken and Egg)

#+begin_src elisp

(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
  
#+end_src

I also manually require =straight-x= which provides some additional experimental functions, most notably =straight-x-fetch-all=.

#+begin_src elisp
(require 'straight-x)
#+end_src

*** org-mode hack

This is the first of hopefully only a few `hacks`, snippets that are particularly unidiomatic and maybe even impossible to understand without knowledge of the associated extensions, mostly because they have to account for some edge-case of said extension, I will have to use in this configuration.

Without this snippet Emacs would load the outdated version of org-mode distributed with its source code, instead of the upstream package from org-elpa. [fn:org-hack]


#+begin_src elisp

;; immediately load the correct org package
(straight-use-package 'org-plus-contrib)

(require 'subr-x)
(straight-use-package 'git)

(with-eval-after-load 'org
  (defun org-git-version ()
    "The Git version of org-mode.
Inserted by installing org-mode or when a release is made."
    (require 'git)
    (let ((git-repo (expand-file-name
                     "straight/repos/org/" user-emacs-directory)))
      (string-trim
       (git-run "describe"
                "--match=release\*"
                "--abbrev=6"
                "HEAD"))))

  (defun org-release ()
    "The release version of org-mode.
Inserted by installing org-mode or when a release is made."
    (require 'git)
    (let ((git-repo (expand-file-name
                     "straight/repos/org/" user-emacs-directory)))
      (string-trim
       (string-remove-prefix
        "release_"
        (git-run "describe"
                 "--match=release\*"
                 "--abbrev=0"
                 "HEAD"))))))

#+end_src

*** hydra
The official hydra wiki provides a hydra for working with straight.el. I edit then bind it to =C-x s=.

The code uses =with-eval-after-load= instead of the superior =use-config= because it has not yet been defined at this point.

#+begin_src elisp

(with-eval-after-load 'straight
  (with-eval-after-load 'hydra
    (defhydra hydra-straight-helper (;
                                     :hint nil
                                     :post (let ((buffer "*straight*"))
                                             ;; For now, automatically close the fetcher window when this hydra exits
                                             (delete-window (get-buffer-window buffer))
                                             (kill-buffer buffer)))
      "
_c_heck package   |_f_etch package     |_m_erge package  |_n_ormalize pack  |p_u_sh package
_C_heck all       |_F_etch all (async) |_M_erge all      |_N_ormlize all    |p_U_sh all    
----------------^^+------------------^^+---------------^^+----------------^^+----_q_uit----|
_r_ebuild package |_p_ull package      |_v_ersions freeze|_w_atcher start   |_g_et recipe
_R_ebuild all     |_P_ull all          |_V_ersions thaw  |_W_atcher quit    |prun_e_ build"
      ("c" straight-check-package)
      ("C" straight-check-all)
      ("r" straight-rebuild-package)
      ("R" straight-rebuild-all)
      ("f" straight-fetch-package)
      ("F" straight-x-fetch-all)
      ("p" straight-pull-package)
      ("P" straight-pull-all)
      ("m" straight-merge-package)
      ("M" straight-merge-all)
      ("n" straight-normalize-package)
      ("N" straight-normalize-all)
      ("u" straight-push-package)
      ("U" straight-push-all)
      ("v" straight-freeze-versions)
      ("V" straight-thaw-versions)
      ("w" straight-watcher-start)
      ("W" straight-watcher-quit)
      ("g" straight-get-recipe)
      ("e" straight-prune-build)
      ("q" nil :color blue))))

(with-eval-after-load 'general
  (general-define-key
    "C-x s" 'hydra-straight-helper/body))

#+end_src

** use-package
This package provides a wrapper macro around Emacs' builtin way of =require=ing packages. It allows for easily specifying the correct order elisp code should be run at, without heavily jeopardizing the actual structure of said code.

Straight.el also provides integration with use-package, allowing for the use of =:straight t=[fn:use-straight] instead of the builtin =:ensure t=. Use-package itself of course gets loaded using only the =straight-use-package= function provided by straight.el

#+begin_src elisp
(straight-use-package 'use-package)
#+end_src

*** use-config macro

I like split the configuration block of a package from its use-package block for visual clarity.
Especially with org-tangle, where I can specify the =use-config= macro to wrap a code block, this approach makes the configuration much more readable.

[TODO: add use-package error handling]

#+begin_src elisp

(defmacro use-config (after &rest body)
  "use-package like wrapper for configurations"
  (macroexp-progn
   (use-package-require-after-load after body)))

(put 'use-config 'lisp-indent-function 'defun)
   
#+end_src

** el-patch
El-patch is a package that allows one to override external package internals in a save manner.
Whenever a value is overridden using one of the =el-patch-*= wrappers, =el-patch-validate= can then be used to validate that the modified code/value has not become outdated due to package updates.

#+begin_src elisp

(use-package el-patch
  :straight t)

#+end_src

** early load
This subtree contains packages and configurations that don't necessarily have anything to do with package management, but should be loaded as early as possible.

*** benchmark-init
I load this package immediately after initializing the use-package/straight system, so it can reliably benchmark all of my startup.

#+begin_src elisp

(use-package benchmark-init
  :straight t
  :config
  ;; To disable collection of benchmark data after init is done.
  (add-hook 'after-init-hook 'benchmark-init/deactivate))

#+end_src

*** bug-hunter
Like benchmark-init, for bug-hunter to be most useful we need to load it as early as possible in our configuration.
This way, even if the configuration fails later, bug-hunter can be used to reliably debug the problem.

#+begin_src elisp
(use-package bug-hunter
  :straight t
  :defer t)
#+end_src

*** no-littering
No-littering is a useful Emacs extension that tries to revert any inconsistent paths used by popular or builtin packages and instead sets them to semantic entries in either =.emacs.d/var= or =.emacs.d/etc=.

#+begin_src elisp

(use-package no-littering
  :straight t)

(use-config (no-littering recentf)
  (add-to-list 'recentf-exclude no-littering-var-directory)
  (add-to-list 'recentf-exclude no-littering-etc-directory))

#+end_src

*** customize
The Emacs customize system normally appends its configurations to the end of the main =init.el= file. This behavior however gets annoying very quickly and also prevents generated configurations (eg. org-mode tangle) from working.

So I simply tell the customize system to write to a another file, =custom.el=.
I would prefer simply not to load this file, as I think the customize system is pointless and stupid, but have to do so as it is (seemingly) the only way to persistently remember save file-local variables.

#+begin_src elisp
(setq custom-file (concat no-littering-etc-directory "custom.el"))
(load custom-file)
#+end_src

*** TODO secrets
* Configuration
The heart and soul of this file and by extension of my Emacs configuration.
Headers are grouped by their most significant functionality. If no logical order is present, alphabetical order should be upheld. [fn:because-vc]

** Helpers
This header contains configurations or packages with the main purpose of easing the configuration of other packages.
For this reason they have to be loaded very early during the initialization. [fn:always-use]

*** general
General allows for easy mapping of keys to commands by adding an abstraction over the builtin =define-key= many well known key-centric extensions such as evil.

#+begin_src elisp

(use-package general
  :straight t
  :defer t)

#+end_src

**** key-fun, key-defun

=key-fun= is an elisp macro written by myself in order to ease the mapping of non-=interactive= functions to keys with general. 
It also makes use of general which-key integration to automatically show clear descriptions.

#+begin_src elisp
(defmacro key-fun (action &rest args)
  (let* ((hint (mapconcat (lambda (it) (format "%s" it))
                          (append (list (symbol-name action)) args) "-"))
         (fun `(lambda (&optional _)
                 (interactive)
                 (apply ',action ',args))))
    `(list ,fun :wk ,(copy-sequence hint))))
(put 'key-fun 'lisp-indent-function 'defun)
#+end_src

Here are some usage examples:

#+begin_src elisp :tangle no
(general-define-key
 "C-y" (key-fun insert "yes"))
#+end_src

=key-defun= is a more general implementation of a similar concept that just takes a name and a body to generate a general-compatible keybinding.

#+begin_src elisp
(defmacro key-defun (name &rest body)
  (let* ((hint (symbol-name name)))
    `(list (lambda () (interactive) ,@body) :wk ,(copy-sequence hint))))
(put 'key-defun 'lisp-indent-function 'defun)
#+end_src

*** key-chord
Key-chord allows mapping the simultaneous pressing of two keys to an additional action. General also includes integration for it through =general-chord=.

Im not quite sure what to think of it yet, but I will enable it for the time being.
Key-chord strangely sends a message when it is enabled. Mitigate this by checking if it has already been enabled.

#+begin_src elisp
(use-package key-chord
 :straight t
 :config
 (when (not (bound-and-true-p key-chord-mode))
   (key-chord-mode 1)))
#+end_src

*** keyfreq
Keyfreq is a package that records your most-often used interactive commands and shows them to you in a table indexed by relative weight.
This allows you ti then look into optimizing your most common (possibly inefficient) actions.

#+begin_src elisp
(use-package keyfreq
  :straight t
  :config
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
#+end_src

*** unpackaged.el
Unpackaged.el is a collection of miscellaneous lisp snippets that are useful, but are not substantial enough to be packaged.
I pull it with straight but then =:ignore= the use-package form, as loading all of it would cause slowdowns.

#+begin_src elisp
(use-package unpackaged
  :disabled t
  :straight (unpackaged :type git :host github
                        :repo "alphapapa/unpackaged.el"))
#+end_src

*** lib
**** async
Async is an emacs-lisp library which offers primitive async/multithreading support through additional processes.
It additionally provides some predefined improvements for builtin Emacs modes.
I use it in some of my functions and configurations.

#+begin_src elisp
(use-package async
  :straight t)
#+end_src

**** dash
Dash is a modern list library for emacs-lisp which can replace the outdated cl-lib libraries.
I use it in some of my functions and configurations.

#+begin_src elisp
(use-package dash
  :straight t
  :config
  (dash-enable-font-lock))
#+end_src

**** f
F is a modern emacs-lisp library for working with files and filesystem paths.
I use it in some of my functions and configurations.

#+begin_src elisp
(use-package f
  :straight t)
#+end_src

**** s
S is a modern emacs-lisp library for string manipulation.
I use it in some of my functions and configurations.

#+begin_src elisp
(use-package s
  :straight t)
#+end_src

**** subr
Subr is an emacs-lisp library that provides common reusable subroutines.
It is distributed with Emacs and some parts load automatically.
I use it in some of my functions and configurations.

#+begin_src elisp
(use-package subr-x)
#+end_src

** Emacs
This is the subtree for configurations that affect all of Emacs.

*** Default
This subtree contains redefinitions for built-in Emacs settings I dislike/want changed.

Force the coding system to be UTF-8 per default everywhere.
#+begin_src elisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)

;; also from xselection
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+end_src

Increase garbage collector threshold. Also manually set maximum recursion and definiton values.
#+begin_src elisp
(setq gc-cons-threshold 50000000)
(setq max-specpdl-size 1200)
(setq max-lisp-eval-depth 800)
#+end_src

Only show y-or-n prompts, even for "important" stuff.
#+begin_src elisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

Show all messages
#+begin_src elisp
(setq inhibit-message nil)
#+end_src

Disallow recursive minibuffers, as they can sometimes cause weird glitches that require Emacs to be restarted.
#+begin_src 
(setq enable-recursive-minibuffers nil)
#+end_src

Disable Emacs from following symlinks as it can lead to unexpected behavior.
#+begin_src elisp
(setq find-file-visit-truename nil)
#+end_src

Set =recenter-positions= to =top= only, so that =C-l= always behaves like it would in terminal.

#+begin_src elisp
(setq recenter-positions '(top))
#+end_src

*** Commands
This subtree contains miscellaneous user-facing commands that I use to manage my Emacs sessions.
They are not prefixed with =my/=.

#+begin_src elisp

(defun reload ()
  "Reload init.el with optional straight integration"
  (interactive)
  (if (featurep 'straight)
      ;; straight.el
      (straight-transaction
        (straight-mark-transaction-as-init)
        (load user-init-file))
    ;; vanilla
    (load user-init-file)))

(defun nuke-buffers ()
  "Kill all emacs buffers but current and internal"
  (interactive)
  (delete-other-windows)
  (--each (--filter
           (not (or (s-prefix? " " (buffer-name it))))
           (cdr (buffer-list)))
    (kill-buffer it)))

(defun nuke-emacs ()
  "Kill all buffers and emacs"
  (interactive)
  (nuke-buffers)
  (kill-buffer (current-buffer))
  (kill-emacs))

#+end_src

*** Keys
Many common tasks by default have some very cumbersome keybindings.
I bind them to shorter/easier keys in this subtree.

+ Reverting
+ Text scaling

#+begin_src elisp

(general-define-key
 "C-c r" 'revert-buffer
 "C-c R" 'auto-revert-mode)

(general-define-key
 "C-=" (key-fun text-scale-set 0)
 "C-+" 'text-scale-increase
 "C--" 'text-scale-decrease)

#+end_src

*** Look
By default Emacs is not much to look at, but by setting some builtin options and loading a nice theme this can easily be changed.

#+begin_src elisp
(scroll-bar-mode 0)
(menu-bar-mode 0)
(toggle-scroll-bar 0)
(tool-bar-mode 0)
#+end_src

**** Themes
There are many nice themes for Emacs.
I personally happen to enjoy the doom, sanityinc and poet families of themes.

#+begin_src elisp
(straight-use-package 'doom-themes)
(straight-use-package 'color-theme-sanityinc-tomorrow)
(straight-use-package 'color-theme-sanityinc-solarized)
(straight-use-package 'poet-theme)
#+end_src

I have also created my own theme

#+begin_src elisp
(add-to-list 'custom-theme-load-path (f-join user-emacs-directory "unmanaged/themes"))
#+end_src

By default Emacs seems to assume that all themes are in fact malware. Disable this behavior.

#+begin_src elisp
(setq custom-safe-themes t)
#+end_src

Sometimes I want to just remove all active themes for debugging purposes. Add a function to easily achieve this.

#+begin_src elisp
(defun disable-all-themes ()
  (interactive)
  "disable all active themes."
  (dolist (i custom-enabled-themes)
    (disable-theme i)))
#+end_src

Because I switch between different themes relatively often, I would like Emacs to always remember and load my currently active theme.
This is achieved here using desktop-mode.

#+begin_src elisp
(use-config desktop
  (add-to-list 'desktop-globals-to-save 'custom-enabled-themes)
  (add-hook 'desktop-after-read-hook (lambda ()
                                       (mapc 'load-theme
                                             custom-enabled-themes))))
#+end_src

**** Modeline
The Emacs modeline is a place for buffers to display arbitrary information grouped in blocks.
The content it shows is defined in the =mode-line-format= variable.

There are different packages that allow one to easily create nice modeline setups.
I am currently using doom-modeline.

#+begin_src elisp

(use-package doom-modeline
  :straight t
  :defer t
  :hook (after-init . doom-modeline-init))

(use-package all-the-icons
  :straight t
  :defer t)

(use-config doom-modeline
  (setq doom-modeline-height 25)
  (setq doom-modeline-bar-width 5)
  (setq doom-modeline-icon t)
  (setq doom-modeline-major-mode-icon nil)
  (setq doom-modeline-major-mode-color-icon nil)
  (setq doom-modeline-persp-name t)
  (setq doom-modeline-lsp t)
  (setq doom-modeline-github nil)
  (setq doom-modeline-github-interval (* 30 60))
  (setq doom-modeline-version t))

#+end_src

#+begin_src elisp
(use-config doom-modeline
  (doom-modeline-def-modeline 'mine
    '(bar workspace-number window-number evil-state matches buffer-info remote-host buffer-position selection-info)
    '(misc-info lsp debug minor-modes input-method buffer-encoding major-mode process vcs checker))
  (doom-modeline-set-modeline 'mine 'default))
#+end_src

**** Bell
I think that both the default beep and the visual bell are too annoying.
Currently I just don't have an abort indicator at all.

#+begin_src elisp
(setq visual-bell nil)
(setq ring-bell-function nil)
#+end_src

**** Fonts
Just like with themes, I would like Emacs to remember the my font across restarts. Again, I use desktop-mode for this.

#+begin_src elisp
(use-config desktop
  (add-to-list 'desktop-globals-to-save 'my/current-font)
  (add-to-list 'desktop-globals-to-save 'my/current-font-size))

(add-hook 'after-make-frame-functions 'my/restore-font)
(advice-add 'load-theme :before 'my/restore-font)
#+end_src

I also define a simple function that allows me to change the global font. My font-remembrance method relies on this function being used to correctly determine the current font.

#+begin_src elisp
(defun set-font (font size)
  (setq my/current-font font)
  (setq my/current-font-size size)
  (set-frame-font (format "%s-%d" font size) nil t))

(defun my/restore-font (&rest _)
  (when (and (bound-and-true-p my/current-font)
             (bound-and-true-p my/current-font-size))
    (set-frame-font (format "%s-%d" my/current-font my/current-font-size) nil t)))
#+end_src

Disable non-monospace fonts (eg. variable-pitch).

#+begin_src elisp
(set-face-attribute 'variable-pitch nil :family "default")
#+end_src

**** Dashboard
Dashboard is an Emacs package ripped from the Spacemacs distribution.
It, like the name suggests, provides a dashboard that can display all different types of content.

Some keys for easier dashboard navigation are bound.

#+begin_src elisp

(use-package dashboard
  :straight t
  :after (evil projectile))

(use-config dashboard
  (setq dashboard-startup-banner (f-join user-emacs-directory "unmanaged/icons/icon.png"))
  (setq dashboard-banner-logo-title "Emacs is sexy!")
  (setq dashboard-items '((recents  . 5)
                          (projects . 5)
                          (bookmarks . 5)
                          (agenda . 5)))
  (set-face-bold 'dashboard-heading-face t)

(general-define-key
 :keymaps 'dashboard-mode-map
 :states 'normal
 "gr" 'dashboard-refresh-buffer))

(add-hook 'dashboard-mode-hook
          (lambda ()
            (general-define-key
             :keymaps 'dashboard-mode-map
             :states 'normal
             "p" (lookup-key dashboard-mode-map "p")
             "r" (lookup-key dashboard-mode-map "r")
             "m" (lookup-key dashboard-mode-map "m"))))

#+end_src

I like to see my dashboard when I open a new frame.

#+begin_src elisp

(defun my/get-or-create-dashboard (&optional concise)
  ;; DONE: Prevent recursive calls from server-process-filter.
  (let ((buffer (get-buffer "*dashboard*")))
    (recentf-cleanup)
    (if buffer
        buffer
      (progn
        (dashboard-insert-startupify-lists)
        (get-buffer "*dashboard*")))))

(setq inhibit-splash-screen nil)
(setq initial-buffer-choice (lambda () (my/get-or-create-dashboard)))

#+end_src

**** Scrollbar                                                      :ARCHIVE:
The yascroll package provides a nice vertical scrollbar that also works in  the terminal. Unfortunately it is no longer maintained and somewhat buggy.
Disable it for now.

#+begin_src elisp :tangle no
(use-package yascroll
  :straight t
  :defer t
  :config
  (require 'cl)
  (setq yascroll:delay-to-hide 0.5)
  (global-yascroll-bar-mode 1))
#+end_src

**** Page breaks
Many Emacs buffers use the =^L= character to indicate a page break.
This package automatically replaces them with a pretty horizontal line.

#+begin_src elisp
(use-package page-break-lines
  :straight t
  :config
  (global-page-break-lines-mode))
#+end_src

*** Terminal
Using Emacs in your terminal unfortunately currently isn't the best experience.
For this reason I still use Vim for most of my on-terminal editing needs.
However I hope that after reconfiguring some of the most common problems when dealing with Emacs in terminal, Emacs will soon be able to fully replace my Vim setup.

First rebind all keys to their correct GUI counterparts.

#+begin_src elisp
;; TAB to actual tab
(define-key input-decode-map "\C-i" [\?t])
#+end_src

*** Navigation
Switching from mostly using terminal utilities to Emacs, the challenge I have faced is having to navigate the large amount of buffers and windows that accumulate during a typical Emacs session.
I still consider what I have achieved so far suboptimal and will have to thoroughly and incrementally improve this part of my configuration until I get something that is usable.

**** TODO Popups/Shackle
One annoying property of Emacs is that it does not distinguish between buffer types. (with exception of the minibuffer) This means that a text buffer, a help buffer and even a helm popup buffer are treated essentially the same way.

Shackle helps me with mitigating one part of this problem by allowing me to easily define special display rules for buffers based on their title or major mode.

It does this by changing =display-buffer-alist=. This means that only buffers displayed using the =display-buffer= function or one of its siblings will be affected.

#+begin_src elisp
(use-package shackle
  :straight t)
#+end_src

I set most shackle rules for builtin Emacs buffer types here. Extensions that provide additional buffers might need additional rules. They should be added in their respective subtrees.

I also set =help-window-select= here because that is something that my shackle setup relies on and it doesn't fit anywhere else.

#+begin_src elisp
(setq shackle-default-rule '()
      shackle-rules '())
(setq help-window-select t)
#+end_src

**** Buffer list
Another consequence of the aforementioned property is that it makes using =previous-buffer=, =next-buffer=, =quit-window= or any function that works with the raw buffer list very unpleasant to use.

I again try to mitigate this problem by creating a function that automatically goes to the next/previous sensible buffer based on context.

These are the library functions I define:

#+begin_src elisp

(defun my/switch-buffer-whitelist (switch-fn whitelist initial-buffer switch-this-run)
  (when switch-this-run
    (apply switch-fn nil)
    (when (eq initial-buffer (current-buffer))
      (user-error "switch-buffer-whitelist: Buffer switch looped")))
  (when (not (--any? (eval it) whitelist))
    (my/switch-buffer-whitelist switch-fn whitelist initial-buffer t)))

#+end_src

I then create some end-user functions based on them and bind them to the right keys.

#+begin_src elisp

(defun my/prev-buffer (&optional include-current)
  (interactive)
  (my/switch-buffer-whitelist 'previous-buffer
                              my/switch-buffer-whitelist
                              (current-buffer)
                              (not include-current)))

(defun my/next-buffer (&optional include-current)
  (interactive)
  (my/switch-buffer-whitelist 'next-buffer
                              my/switch-buffer-whitelist
                              (current-buffer)
                              (not include-current)))

;; TODO: improve with content-aware delete/kill
(defun my/delete-window-or-kill-buffer (&optional kill-always)
  (interactive)
  (unless (window--delete nil nil kill-always)
    (if (string= (buffer-name) "*scratch*")
        (previous-buffer)
      (kill-buffer)))
  (my/prev-buffer t))

(defconst my/switch-buffer-whitelist
  '((buffer-file-name)
    (bound-and-true-p org-src-mode)
    (bound-and-true-p dired-filter-mode)
    (string-match-p "\\*scratch\\*" (buffer-name))))

(general-define-key
 "<XF86Back>" 'my/prev-buffer
 "<XF86Forward>" 'my/next-buffer)

(general-define-key
 :keymaps 'override
 "C-q" 'my/delete-window-or-kill-buffer)

(general-define-key
 :keymaps 'help-mode-map
 "<XF86Back>" 'help-go-back
 "<XF86Forward>" 'help-go-forward)

#+end_src

**** Tabs/Eyebrowse
Eyebrowse is an extension that offers basic tab functionality in Emacs. It works by simply saving a list of all the window configurations.

#+begin_src elisp

(use-package eyebrowse
  :straight t
  :config
  (eyebrowse-mode 1))

(use-config eyebrowse
  ;; unbind default eyebrowse keys
  (setq eyebrowse-mode-map (make-sparse-keymap))
  (setq eyebrowse-wrap-around t))

#+end_src

**** Keys
For buffer and window management I bind quite a lot of keys, most of them under the =C-a= prefix.

These keys depend on the ace-window, evil, eyebrowse, and dashboard packages.

#+begin_src elisp

(general-define-key
 :keymaps 'override
 :states '(normal insert visual motion emacs)
 :prefix "C-a"
 "s" 'ace-window
 "o" 'other-window
 "O" (key-fun other-window -1)

 "d" (key-fun switch-to-buffer "*dashboard*")
 "c" 'my/eyebrowse-buffer
 
 "n" 'eyebrowse-next-window-config
 "p" 'eyebrowse-prev-window-config
 "a" 'delete-other-windows
 "x" 'my/close-window-or-eyebrowse
 "X" 'eyebrowse-close-window-config

 "w" (key-defun split-window-vertically
        (split-window-below)
        (evil-window-down 1))
 "q" (key-defun split-window-horizontally
        (split-window-right)
        (evil-window-right 1))
 
 "h" 'evil-window-left
 "j" 'evil-window-down
 "k" 'evil-window-up
 "l" 'evil-window-right
 "C-k" (key-fun evil-window-move-very-top)
 "C-j" (key-fun evil-window-move-very-bottom)
 "C-h" (key-fun evil-window-move-far-left)
 "C-l" (key-fun evil-window-move-far-right))

;; [TODO: use el-patch]
(defun my/eyebrowse-buffer ()
  (interactive)
  (setq this-command #'ivy-switch-buffer)
  (ivy-read "Switch to buffer: " #'internal-complete-buffer
            :keymap ivy-switch-buffer-map
            :preselect (buffer-name (other-buffer (current-buffer)))
            :action (lambda (b)
                      (eyebrowse-create-window-config)
                      (delete-other-windows)
                      (switch-to-buffer b))
            :matcher #'ivy--switch-buffer-matcher
            :caller 'ivy-switch-buffer))

(defun my/eyebrowse-projectile-project ()
  (interactive)
  (let ((projectile-switch-project-action
         (lambda ()
           (eyebrowse-create-window-config)
           (delete-other-windows)
           (projectile-find-file))))
    (projectile-switch-project)))

(defun my/close-window-or-eyebrowse ()
  (interactive)
  (when (condition-case nil (evil-window-delete) (error t))
    (eyebrowse-close-window-config)))

#+end_src

I also bind some other commands for finding buffers and files. These are primarily useful when not in an projectile project.

#+begin_src elisp

(general-define-key
 :prefix "C-x"
 :keymaps 'override
 "b" 'ivy-switch-buffer
 "k" 'kill-buffer)

(general-define-key
 :prefix "C-x"
 :keymaps 'override
 "f" 'counsel-find-file
 "C-f" 'counsel-locate
 "F" 'counsel-fzf)

#+end_src

*** OS Integration
While living in Emacs is /of course/ the ultimate goal, I would also like to enjoy some of the benefits the last +40 years have brought us.
Being able to actually browse modern webpages is OFC also a plus.

#+begin_src elisp
(setq browse-url-generic-program "firefox")
#+end_src

#+begin_src elisp

(use-package openwith
  :straight t
  :config
  (openwith-mode t)
  (setq openwith-associations nil))

(use-config openwith
   (setq openwith-associations '(("\\.pdf\\'" "zathura" (file)))))

#+end_src

*** Interface Extensions
Because Emacs is so very extensible, it is also possible to add entirely new interfaces to its core functionality. Many of these "interface extensions" are some of the most widely used Emacs packages.
Packages that fall into this category might include the builtin IDO, helm and ivy. They are often referred to as "narrowing completion frameworks".
Other than that there is also hydra, a package for defining colorful keyboard-centric pop-up menus and evil, the extensible vi layer. [fn:evil-where]

**** Evil
Evil is the extensible vi(m) layer for Emacs. It provides WORD vim emulation for Emacs, including motions, text objects visual, visual block and line selection, the vim command line, improved isearch [TODO fix ugly artefacts], interactive search and replace as well as ports of many popular vim extensions.
Evil is activated through the global-only =evil-mode= and changes a huge amount of mappings. It also introduces the concept of states and intercept keymaps which are fortunately handled relatively well by general.

Vim also inexplicably has =Y= mapped to yanking the whole line instead of point -> eol like =D= and =C=. Evil has an option to disable this behavior.

#+begin_src elisp

(use-package evil
  :straight t
  :init
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  (setq evil-want-minibuffer t)
  (setq evil-want-Y-yank-to-eol t)
  (setq evil-want-fine-undo t)
  :config
  (evil-mode 1))

(use-config evil
  (evil-select-search-module 'evil-search-module 'evil-search)
  (setq evil-ex-complete-emacs-commands t)
  
  (setq evil-cross-lines nil
        evil-move-beyond-eol nil
        evil-symbol-word-search nil)
  
  (setq evil-motion-state-cursor 'box   ; █
        evil-visual-state-cursor 'box   ; █
        evil-normal-state-cursor 'box   ; █
        evil-insert-state-cursor 'bar   ; ⎸
        evil-emacs-state-cursor 'hbar)) ; _

#+end_src

***** Bindings
Some mode-agnostic additional evil bindings.

I bind =j+k= to go from insert to normal state through key-chord.

#+begin_src elisp
(general-define-key
 :states '(insert)
 (general-chord "jk") 'evil-normal-state
 (general-chord "kj") 'evil-normal-state)
#+end_src

***** Additional [0/2]
Vim has some well-liked plugins, some of which have been ported to evil.
I enable the ones I like here.

****** Motions
Evil surround and commentary emulate the popular vim plugins of the same name. They automatically bind their keys through =evil-surround-mode= and =evil-commentary-mode=.

#+begin_src elisp
(use-package evil-surround
  :straight t
  :after evil
  :config
  (global-evil-surround-mode 1))
#+end_src

#+begin_src elisp
(use-package evil-commentary
  :straight t
  :after evil
  :config
  (evil-commentary-mode 1))
#+end_src

****** TODO Multiple cursors
evil-multiedit or evil-mc
****** TODO Evil-terminal-cursor-change
***** Integration
****** Evil-collection
Evil-collection aims to bring the advantages of the vim modal editing model to many popular Emacs modes. It can sometimes be problematic, as it may override user-defined bindings.

#+begin_src elisp
(use-package evil-collection
  :straight t
  :init
  (setq evil-collection-setup-minibuffer t))
#+end_src

Integration may be activated for a specific mode in the following fashion:

#+begin_src elisp :tangle no
(evil-collection-MODE-setup)
#+end_src

Where MODE is the mode to which you want to add the evil integration.
I usually do this in the =:init= part of any particular use-package declaration.

****** Builtin
Some builtin Emacs modes don't properly integrate with evil-mode and also have no evil-collection support.
I add basic support for them here.

#+begin_src elisp
(general-define-key
 :keymaps 'finder-mode-map
 :states '(insert normal visual)
 "q" 'finder-exit
 "<return>" 'finder-select)
#+end_src

#+begin_src elisp
(general-define-key
 :keymaps 'package-menu-mode-map
 :states 'emacs
 "j" 'forward-button
 "k" 'backward-button)
;; (add-hook 'package-menu-mode-hook 'forward-button)
#+end_src

****** Insert Mark
With some Emacs packages (notably lispy) it is useful to have an active mark in insert state.
However evil by default doesn't expect this, causing things to mess up in unexpected ways.
For this reason I configure evil to first deactivate the active mark when switching to normal-state.

#+begin_src elisp
(advice-add 'evil-normal-state :around 'my/advice-evil-normal-state)
(defun my/advice-evil-normal-state (fun &optional arg)
  (if mark-active
      (deactivate-mark)
    (apply fun (list arg))))
#+end_src

****** Minibuffer
One problem with evil I have is that, when it is enabled for the minibuffer, it binds the =<escape>= key to normal mode overriding the default exit function.
This works well for =eval-expression= and maybe others, but not for things like ivy, helm, or even the evil command line.
For this reason I rebind the =<escape>= keys for the evil command line, as well as vanilla minibuffer here. The other interfaces are managed in ther respective subtrees.
For when I really want to utilize normal mode I also rebind =C-o= to =evil-ex-normal=.
The hook is needed so that evil immediately recognizes we are in insert state in the minibuffer.

#+begin_src elisp

(general-define-key
 :keymaps '(evil-ex-completion-map evil-ex-search-keymap minibuffer-local-map)
 :states 'insert
 "C-o" 'evil-normal-state
 "<escape>" 'keyboard-escape-quit)

(add-hook 'minibuffer-setup-hook 'evil-insert-state)

#+end_src

As previously mentioned, I want =<escape>= to bring me to normal mode for =eval-expression=.

#+begin_src elisp

(defvar my/minibuffer-evil-commands
  '(eldoc-eval-expression eval-expression))

(defun my/minibuffer-maybe-setup-evil ()
  (if (--any? (eq it this-command) my/minibuffer-evil-commands)
      (setq-local my/minibuffer-wants-evil t)
    (setq-local my/minibuffer-wants-evil nil)))

(add-hook 'minibuffer-setup-hook 'my/minibuffer-maybe-setup-evil)

(defun my/minibuffer-normal-or-exit ()
  (interactive)
  (if my/minibuffer-wants-evil
      (evil-normal-state)
    (keyboard-escape-quit)))

(general-define-key
 :keymaps 'minibuffer-local-map
 :states 'insert
 "<escape>" 'my/minibuffer-normal-or-exit)

#+end_src

However an =<escape>= key-press when already in normal mode should always allow me to exit the minibuffer.

#+begin_src elisp
(general-define-key
 :keymaps 'minibuffer-local-map
 :states 'normal
 "<escape>" 'keyboard-escape-quit)
#+end_src

****** Mouse
To perfectly emulate vim, evil also rebinds certain mouse clicks/actions. I find most of these annoying as they sometimes interfere with other Emacs functionality (eg. buttons), so I try to rebind them. [TODO: rebind all]

#+begin_src elisp
(general-define-key
 :keymaps 'evil-motion-state-map
 [down-mouse-1] nil)
#+end_src

**** Ivy
Ivy is the best available narrowing completion framework. It, unlike helm, makes use of the minibuffer for its main interface.
The ivy repo also includes swiper, an isearch replacement with an overview and the counsel utilities, which are wrappers arround existing commands with added ivy completion.
Moreover by enabling =ivy-mode= you may allow ivy to automatically hijack well known completion functions. =counsel-mode= does the same but with some of the more opinionated counsel interfaces.

#+begin_src elisp

(use-package ivy
  :straight t
  :init
  (setq ivy-do-completion-in-region nil)
  (evil-collection-ivy-setup)
  :config
  (ivy-mode 1))

;; (use-package swiper
;;   ;; swiper is distributed with ivy
;;   :after ivy)

(use-package counsel
  :straight t
  :after (ivy)
  :config
  (counsel-mode 1))

#+end_src

Bind =<RET>= to immediately execute the current ivy selection and =<tab>= to first complete it if possible.
Keys for executing different types of dispatch may be bound in the future.

#+begin_src elisp

(use-config ivy
  (setq ivy-use-selectable-prompt t))

(general-define-key
 :keymaps 'ivy-minibuffer-map
 :states 'insert
 "<RET>" 'ivy-done
 "<tab>" 'ivy-partial-or-done)

#+end_src

I bind swiper to =/= in normal or visual mode.
It thus replaces the default isearch/evil-isearch for me.

#+begin_src elisp

(general-define-key
 :states '(normal visual)
 "/" 'swiper)
 
#+end_src

Counsel provides the =counsel-describe-map= which has bindings for going to the definition of commands (=C-.=) as well as acessing the info documentation (=C-,=), but not for acessing help documentation.
I mainly use this functionality from =counsel-M-x=.

#+begin_src elisp

(defun my/counsel-help-lookup-symbol ()
  "Lookup the current symbol in the help docs."
  (interactive)
  (ivy-exit-with-action (lambda (x) (describe-symbol (intern x)))))

(general-define-key
 :keymaps 'counsel-describe-map
 "C-h" 'my/counsel-help-lookup-symbol)

#+end_src


A hydra for easier navigation is also provided. Keys for accessing the hydra in ivy-minibuffers are bound.
I also rebind =<escape>= here to ensure it always closes the hydra.

#+begin_src elisp

(general-define-key
 :keymaps 'ivy-minibuffer-map
 :states '(insert normal)
 "C-o" 'better-ivy/body
 "<escape>" 'better-ivy/keyboard-escape-quit-and-exit)

(defun better-ivy/get-ivy-matcher-desc ()
  "Return description of `ivy--regex-function'."
  (let ((cell (assq ivy--regex-function ivy-preferred-re-builders)))
    (if cell
        (cdr cell)
      "other")))

(use-config (ivy hydra)
  (defhydra better-ivy (:hint nil :color pink)
    "
 Move     ^^^^^^^^^^ | Call         ^^^^ | Cancel^^ | Options^^ | Action _w_/_s_/_a_: %s(ivy-action-name)
----------^^^^^^^^^^-+--------------^^^^-+-------^^-+--------^^-+---------------------------------
 _g_ ^ ^ _k_ ^ ^ _u_ | _f_orward _o_ccur | _i_nsert | _c_alling: %-7s(if ivy-calling \"on\" \"off\") _C_ase-fold: %-10`ivy-case-fold-search
 ^↨^ _h_ ^+^ _l_ ^↕^ | _RET_ done     ^^ | _q_uit   | _m_atcher: %-7s(better-ivy/get-ivy-matcher-desc) _t_runcate: %-11`truncate-lines
 _G_ ^ ^ _j_ ^ ^ _d_ | _TAB_ alt-done ^^ | ^ ^      | _<_/_>_: shrink/grow
"
    ;; arrows
    ("j" ivy-next-line)
    ("k" ivy-previous-line)
    ("l" ivy-alt-done)
    ("h" ivy-backward-delete-char)
    ("g" ivy-beginning-of-buffer)
    ("G" ivy-end-of-buffer)
    ("d" ivy-scroll-up-command)
    ("u" ivy-scroll-down-command)
    ("e" ivy-scroll-down-command)
    ;; actions
    ("q" keyboard-escape-quit :exit t)
    ("C-g" keyboard-escape-quit :exit t)
    ("<escape>" keyboard-escape-quit :exit t)
    ("C-o" nil)
    ("i" nil)
    ("TAB" ivy-alt-done :exit nil)
    ("C-j" ivy-alt-done :exit nil)
    ;; ("d" ivy-done :exit t)
    ("RET" ivy-done :exit t)
    ("C-m" ivy-done :exit t)
    ("f" ivy-call)
    ("c" ivy-toggle-calling)
    ("m" ivy-toggle-fuzzy)
    (">" ivy-minibuffer-grow)
    ("<" ivy-minibuffer-shrink)
    ("w" ivy-prev-action)
    ("s" ivy-next-action)
    ("a" ivy-read-action)
    ("t" (setq truncate-lines (not truncate-lines)))
    ("C" ivy-toggle-case-fold)
    ("o" ivy-occur :exit t)))


#+end_src

Add a sort-by-length ivy sort functions that can later be used by different completion functions.

#+begin_src elisp
(defun my/ivy-sort-by-length (_name candidates)
  (-sort (lambda (f1 f2)
           (< (length f1) (length f2)))
         (copy-sequence candidates)))
#+end_src

You can set the sort function by adding it to the =ivy-sort-matches-function-alist= like so:

#+begin_src elisp :tangle no
(add-to-list 'ivy-sort-matches-functions-alist
             '(CALLER-FUNCTION . SORT-FUNCTION)
             t)
#+end_src

I immediately do this for =find-file=.

#+begin_src elisp
(add-to-list 'ivy-sort-matches-functions-alist
             '(counsel-find-file . my/ivy-sort-by-length)
             t)
#+end_src

**** Helm
Helm is the most well known narrowing completion framework for Emacs. It also has the largest amount of completion sources. Unfortunately it is no longer fully maintained, slower than ivy and somewhat intrusive.

I personally load this package for some of it's additional sources, but do NOT enable =helm-mode=.

#+begin_src elisp

(use-package helm
  :straight t
  :defer t)

(use-config helm
  ;; allow display settings to be overriden
  (setq helm-display-function 'pop-to-buffer))
  
#+end_src

Just like with ivy an, albeit inferior, hydra is provided. Keys for accessing it in the helm buffer are bound.
I also rebind =<escape>= here to ensure it always closes the helm buffer.

#+begin_src elisp

(general-define-key
 :keymaps '(helm-map helm-M-x-map)
 :states '(insert normal emacs visual)
 "C-o" 'hydra-helm/body
 "<escape>" 'helm-keyboard-quit)

(use-config (hydra helm)
  (defhydra hydra-helm (:hint nil :color pink)
    "
                                                                          ╭──────┐
   Navigation   Other  Sources     Mark             Do             Help   │ Helm │
  ╭───────────────────────────────────────────────────────────────────────┴──────╯
        ^_k_^         _K_       _p_   [_m_] mark         [_v_] view         [_H_] helm help
        ^^↑^^         ^↑^       ^↑^   [_t_] toggle all   [_d_] delete       [_s_] source help
    _h_ ←   → _l_     _c_       ^ ^   [_u_] unmark all   [_f_] follow: %(helm-attr 'follow)
        ^^↓^^         ^↓^       ^↓^    ^ ^               [_y_] yank selection
        ^_j_^         _J_       _n_    ^ ^               [_w_] toggle windows
  --------------------------------------------------------------------------------
        "
    ("<tab>" helm-keyboard-quit "back" :exit t)
    ("<escape>" nil "quit")
    ("\\" (insert "\\") "\\" :color blue)
    ("h" helm-beginning-of-buffer)
    ("j" helm-next-line)
    ("k" helm-previous-line)
    ("l" helm-end-of-buffer)
    ("g" helm-beginning-of-buffer)
    ("G" helm-end-of-buffer)
    ("n" helm-next-source)
    ("p" helm-previous-source)
    ("K" helm-scroll-other-window-down)
    ("J" helm-scroll-other-window)
    ("c" helm-recenter-top-bottom-other-window)
    ("m" helm-toggle-visible-mark)
    ("t" helm-toggle-all-marks)
    ("u" helm-unmark-all)
    ("H" helm-help)
    ("s" helm-buffer-help)
    ("v" helm-execute-persistent-action)
    ("d" helm-persistent-delete-marked)
    ("y" helm-yank-selection)
    ("w" helm-toggle-resplit-and-swap-windows)
    ("f" helm-follow-mode)))

#+end_src

**** Hippie-expand
Hippie-expand provides expansion based on multiple different simultaneous sources.
I don't use it often, but it can sometimes be nice to have.

The default =hippie-expand= gets bound to =<C-y>= in insert and normal mode.

#+begin_src elisp

(use-package hippie-expand
  :defer t)

(general-define-key
 :states '(normal insert)
 "C-y" 'hippie-expand)

#+end_src

**** Hydra
Hydra is a package that allows the end user or library authors to define keyboard-centric menus of arbitrary complexity. They may also define a doc-string which is then displayed as a formatted, visual presentation of the menu.

#+begin_src elisp

(use-package hydra
  :straight t)

#+end_src

**** Smex                                                           :ARCHIVE:
Smex is a smart replacement for the default =M-x= interface using the IDO NCS system.
=counsel-M-x= automatically detects when smex is loaded and then interfaces with it.

#+begin_src elisp :tangle no
(use-package smex
 :straight t)
#+end_src
.
**** Amx
Amx is the successor to the no longer maintained smex.
Like smex it also has =counsel-M-x= integration.

#+begin_src elisp
(use-package amx
  :straight t)
#+end_src

**** Which-key
Which-key is a package that initially comes from the Spacemacs distribution.
It shows a grid of valid further key combinations after an initial keypress.

#+begin_src elisp
(use-package which-key
  :straight t
  :init
  :config
  (setq which-key-allow-evil-operators t)
  (which-key-mode 1))
#+end_src

*** Saving
Saving/Preserving state in Emacs is a complicated affair, here are my settings for it:

**** Auto-save
Periodically save edited buffers. This can be helpful should Emacs/your computer decide to crash during an editing session.

#+begin_src elisp
(setq auto-save-list-file-prefix "~/.emacs.d/var/auto-save/files")
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/var/auto-save/files" t)))
#+end_src

**** Backup
Backup all saved files as well as auto-save files. This can be helpful if you accidentally override a file that isn't in version control/hasn't been commited for a while.

#+begin_src elisp
(setq make-backup-files t
      version-control t
      kept-new-versions 10
      kept-old-versions 0
      delete-old-versions t
      backup-by-copying t)

(setq backup-directory-alist `(("." . "~/.emacs.d/var/backup")))
#+end_src

**** Desktop
Desktop-save-mode is a global minor mode that allows storing information about the current Emacs session to restore at a later date.

It is mostly useful for preserving opened buffers and edits made to them, but additional variables can be preserved by adding them to =desktop-globals-to-save=.

#+begin_src elisp
(setq desktop-dirname             "~/.emacs.d/var/desktop/"
      desktop-base-file-name      "emacs.desktop"
      desktop-base-lock-name      "lock"
      desktop-path                (list desktop-dirname)
      desktop-save                t
      desktop-files-not-to-save   "^$"  ;reload tramp paths
      desktop-load-locked-desktop t
      desktop-auto-save-timeout   0
      desktop-restore-frames      nil
      desktop-restore-eager       20
      desktop-restore-in-current-display nil)
#+end_src

Multiple running Emacsen confuse desktop-save, causing it to uslessly prompt the user. Only enable desktop-save-mode in the first Emacs instance that is spawned.

#+begin_src elisp

;; append to make sure this gets run after modeline setup
(add-hook 'after-init-hook 'my/maybe-enable-desktop t)

(defun my/maybe-enable-desktop ()
  (if (f-exists?
       (f-join desktop-dirname desktop-base-lock-name))
      (message "Desktop save is off!")
    (progn
      (require 'desktop)
      (desktop-save-mode 1)
      (if (not (ignore-errors (desktop-read)))
          (message "Desktop save failed loading. There are probably some unset protected variables.")
        (message "Desktop save is on!")))))

#+end_src

**** Recentf
Recentf is Emacs' default library for storing the last visited files.

I simply raise the saved items to a relatively high value and exclude some directories that would otherwise fill up the cache.
I also bind =C-x l= to =counsel-recentf= for convenient access.

#+begin_src elisp

(use-package recentf
  :straight nil
  :config
  (recentf-mode 1))

(use-config recentf
  (setq recentf-max-menu-items 20)
  (setq recentf-max-saved-items 50)
  (add-to-list 'recentf-exclude "/\\.emacs\\.d/elpa")
  (add-to-list 'recentf-exclude "/nix/store")
  (add-to-list 'recentf-exclude "\\.orhc-bibtex-cache"))

(general-define-key
 "C-x l" 'counsel-recentf)

#+end_src

**** Savehist
Savehist seems to be the default Emacs mechanism to save minibuffer history. I of course want that to always be enabled.

#+begin_src elisp
(savehist-mode 1)
#+end_src

*** Undo
The default Emacs =undo= command is somewhat unusual, requiring aid of additional plugins for me to use comfortably.

**** undo-tree
Undo-tree is an Emacs package that tries to improve Emacs' undo and redo functionality by offering a tree-style undo action viewer, as well as undo persistence. It is depended on by evil.

Unfortunately the original author of the package seems to have lost interest in updating it. For this reason it is plagued by bugs.

Because Emacs does not currently have another undo system I deem "intuitive" or even "usable" at this point, I am still willing to put up with the danger of undo-tree eventually messing up something.

Important problems with undo-tree:
+ auto-save-history feature may cause emacs to inexplicably crash
+ "branches" in the undo-tree will sometimes prevent you from redoing changes

#+begin_src elisp
(use-package undo-tree
  :straight t
  :config
  (setq undo-tree-auto-save-history t)
  (setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/var/undo")))
  (global-undo-tree-mode 1))
#+end_src

Never hide the place where undos are happening in org-mode.

#+begin_src elisp
(defun my/undo-tree-org-reveal (&rest _)
  (org-reveal))
(advice-add 'undo-tree-undo :after 'my/undo-tree-org-reveal)
(advice-add 'undo-tree-undo :after 'my/undo-tree-org-reveal)
#+end_src

**** MAYBE undohist                                                 :ARCHIVE:
**** undo-propose                                                   :ARCHIVE:
Undo-propose aims to be a non-intrusive, minimal addition to the undo-system, by preserving the existing undo functionality of Emacs, but isolating it into its own, separate buffer.

#+begin_src elisp :tangle no
(use-package undo-propose
  :straight t)
#+end_src

I define my own hydra for it, whose body then replaces the default undo bindings.

#+begin_src elisp :tangle no

(eval
 `(defhydra hydra-undo-propose (;;
                                :exit nil
                                :foreign-keys warn
                                :hint nil
                                :body-pre (undo-propose))
    "
Undo: _u_, _q_, other
"
    ,@(-map (lambda (key) `(,key (undo-propose-finish) :exit t))
             (-map 'char-to-string
                   (number-sequence ?a ?z)))
    ("<escape>" (progn nil))
    ("u" (undo))
    ("d" (message "hydra-undo-propose: diff not yet implemented"))
    ("q" (undo-propose-cancel) :exit t)))

(general-define-key
 :keymaps 'global
 :states '(normal)
 "u" 'hydra-undo-propose/body)

;; override undo keys in undo-propose buffers
(general-define-key
 :definer 'minor-mode
 :keymaps 'undo-propose-mode
 :states '(normal)
 "u" 'undo-propose-undo)

#+end_src
.
** Editing
*** Prelude-esque
The [[https://github.com/bbatsov/prelude#helm][Emacs Prelude]] project, among other things, provides a set of helpful and generic keybindings for editing text.
I have extracted some of them for my own configuration.

**** Operate-on-number
These are bindings for operating on numbers arround point.

The operate-on-number package used by Emacs Prelude is over-complicated and buggy, so I implement my own version here.

#+begin_src elisp

(defun my/operate-on-number (fun &rest args)
  (let* ((old-point (point))
         (match (or (my/oon-find-number)
                    (user-error "No number at point")))
         (old-string (nth 2 match))
         (result (apply fun `(,(string-to-number old-string) ,@args)))
         (add-operator (if (and (nth 3 match) (>= result 0)) "+" ""))
         (new-string (format "%s%s" add-operator result)))
    (delete-region (nth 0 match) (nth 1 match))
    (insert new-string)
    (goto-char old-point)
    (backward-char (- (length old-string)
                      (length new-string)))))

(defun my/oon-find-number ()
  (save-excursion 
    (when (looking-at "[+-]")
      (forward-char))
    (skip-chars-backward "0-9.")
    (when (looking-back "e[-+]")
      (backward-char 2)
      (skip-chars-backward "0-9."))
    (when (looking-back "[+-]")
      (backward-char))
    (if (looking-at "\\([+-]\\)?[0-9]+\\(\\.[0-9]+\\)?\\(e[+-][0-9]+\\)?")
        (let* ((has-operator (if (match-beginning 1) t nil))
               (start (match-beginning 0))
               (end (match-end 0))
               (num (buffer-substring-no-properties start end)))
          `(,start ,end ,num ,has-operator))
      nil)))

(defun my/oon-defop (fun default-arg &optional name-symbol)
  (let* ((name-symbol (cond (name-symbol (intern name-symbol))
                            ((symbolp fun) fun)
                            (t (user-error "Please provide either a named function or a name to oon-defop"))))
         (name (format "operate-%s-default-%s" name-symbol default-arg)))
    (eval `(defun ,(intern name)
               (&optional arg)
             (interactive "P")
             (my/operate-on-number ',fun
                                   (if arg
                                       arg
                                     ,default-arg))))))

(defun my/oon-calc ()
  (interactive)
  (my/operate-on-number (lambda (num)
                          (string-to-number
                           (calc-eval
                            (read-from-minibuffer
                             "calc: "
                             (number-to-string num)))))))
#+end_src

I bind several of these operations to keys under the normal === prefix.

#+begin_src elisp

(general-unbind
  :states '(normal visual)
  "=")

(general-define-key
 :states '(normal visual)
 :prefix "="
 "+" (my/oon-defop '+ 1)
 "-" (my/oon-defop '- 1)
 "*" (my/oon-defop '* 2)
 "/" (my/oon-defop '/ 2)
 "^" (my/oon-defop 'expt 2)
 "<" (my/oon-defop 'ash 1 "lsh")
 ">" (my/oon-defop (lambda (val arg) (ash val (- arg))) 1 "rsh")
 "%" (my/oon-defop '% 2)
 "=" 'my/oon-calc)

#+end_src

**** Insert-shell-command
The default =shell-command= has interactive functionality and can even be inserted into the buffer with the =C-u= prefix argument.
Unfortunately it does not trim trailing whitespace from the returned output.

The =evil-shell-command= also behaves unituitively.

So I define my own version and bind it to some easily acessible keys. 

#+begin_src elisp

(defun my/insert-shell-command (command)
  (interactive
   (list (read-string "Shell command: ")))
  (insert
   (s-trim-right (shell-command-to-string command))))

(general-define-key
 :states '(normal visual)
 "=!" 'my/insert-shell-command)

(general-define-key
 "C-!" 'my/insert-shell-command)

#+end_src

*** Visual line
When I have enabled =visual-line-mode=, I want visual lines to be treated nearly the same as hard lines would be without it.
This means that some evil keys have to be rebound.
Note that motions that operate on lines such as for example "dd" still operate on hard lines.

#+begin_src elisp

(defun my/evil-visual-line-I ()
  (interactive)
  (evil-first-non-blank-of-visual-line)
  (evil-insert 1))

;; [MAYBE TODO: make sure these properly finds the last char]
(defun my/evil-visual-line-A ()
  (interactive)
  (evil-end-of-visual-line)
  (evil-insert 1))

(defun my/evil-visual-line-C ()
  (interactive)
  (evil-delete (point)
               (progn
                 (evil-end-of-visual-line)
                 (point)))
  (evil-insert 1))

(defun my/evil-visual-line-D ()
  (interactive)
  (evil-delete (point)
               (progn
                 (evil-end-of-visual-line)
                 (point))))

(defun my/evil-visual-line-Y ()
  (interactive)
  (save-excursion
    (evil-yank (point)
               (progn
                 (evil-end-of-visual-line)
                 (point)))))
#+end_src

#+begin_src elisp

(general-define-key
 :states 'normal
 :definer 'minor-mode
 :keymaps 'visual-line-mode
 "j" 'evil-next-visual-line
 "k" 'evil-previous-visual-line
 "^" 'evil-first-non-blank-of-visual-line
 "$" 'evil-end-of-visual-line
 "I" 'my/evil-visual-line-I
 "A" 'my/evil-visual-line-A
 "D" 'my/evil-visual-line-D
 "C" 'my/evil-visual-line-C
 "Y" 'my/evil-visual-line-Y
 "<down>" 'evil-next-visual-line
 "<up>" 'evil-previous-visual-line)

(general-define-key
 :definer 'minor-mode
 :keymaps 'visual-line-mode
 :states '(normal insert)
 "<down>" 'evil-next-visual-line
 "<up>" 'evil-previous-visual-line)

#+end_src

Visual-fill-column provides a =fill-column=-like experience for buffers using =visual-line-mode=.

#+begin_src elisp
(use-package visual-fill-column
  :straight t
  :defer t
  ;; :hook (visual-line-mode . visual-fill-column-mode)
  )
#+end_src

*** Smart backspace
Most IDEs by default have some sort of "smart-backspace" functionality that allows for easier navigation of indented text.
What that mostly boils down to is that when on an empty line indented, pressing =<backspace>= deletes the whole line and goes to the previous lines indentation.

I like this behavior, so I implement and bind it here.

#+begin_src elisp

(defun my/smart-backspace ()
  (interactive)
  (cond
   ((looking-back "^[[:space:]]+")
    (my/sb-delete-to-previous-line))
   (t
    ;; delete char normally 
    (call-interactively 'backward-delete-char))))

(defun my/smart-backspace-word ()
  (interactive)
  (cond
   ((looking-back "^[[:space:]]+")
    (my/sb-delete-to-previous-line))
   (t
    ;; delete word normally
    (call-interactively 'backward-kill-word))))

(defun my/sb-delete-to-previous-line ()
  ;; delete all spaces
  (while (not (looking-back "[\n]"))
    (delete-char -1))
  ;; delete final newline
  (delete-char -1)
  ;; go to indentation
  (when (looking-back "[\n]")
    (indent-according-to-mode)))

(general-define-key
 :keymaps '(prog-mode-map text-mode-map)
 :states 'insert
 "<backspace>" 'my/smart-backspace
 "<C-backspace>" 'my/smart-backspace-word)

#+end_src

*** Narrowing
The endlessparens website shows a DWIM-style command that can replace most of the complicated narrowing bindings.
I adapt it to my liking and then bind it to normal =zn=. 
I additionally bind my personal DWIM widen command to normal =zw=.

#+begin_src elisp

(defun my/narrow-dwim (p)
  (interactive "P")
  (cond
   ((region-active-p)
    (narrow-to-region (region-beginning)
                      (region-end)))
   ((derived-mode-p 'org-mode)
    ;; `org-edit-src-code' is not a real narrowing
    ;; command. Remove this first conditional if
    ;; you don't want it.
    (cond
     ((ignore-errors (org-edit-src-code) t))
     ((ignore-errors (org-narrow-to-block) t))
     (t (org-narrow-to-subtree))))
   ((derived-mode-p 'latex-mode)
    (LaTeX-narrow-to-environment))
   (t (narrow-to-defun))))

(defun my/widen-dwim ()
  (interactive)
  (cond
   ((bound-and-true-p org-src-mode)
    (org-edit-src-exit))
   (t (widen))))

(general-define-key
 :states '(normal visual)
 "zn" 'my/narrow-dwim
 "zw" 'my/widen-dwim)

#+end_src

*** Pairs
While there are programming language specific packages that handle automatic pairing (eg. lispy) I would like to have this functionality for all programming languages as well as prose.
Smartparens has automatic detection for most programming and markup languages, as well as sensible defaults for unknown modes.

#+begin_src elisp

(use-package smartparens
  :straight t
  :config
  (require 'smartparens-config)
  (smartparens-global-mode 1))

#+end_src

Using lispy has also made me dependent the ability to slurp and barf sexps.
Bind keys to access that functionality in non-lisp buffers.

#+begin_src elisp

(general-define-key
 :states 'normal
 ">" 'sp-forward-slurp-sexp
 "<" 'sp-forward-barf-sexp)

#+end_src

For c-style languages, I would like to be able to automatically have braces indented for me. [TODO: Language handling]

#+begin_src elisp

(defun my/indent-between-braces (&rest _ignored)
  "Open a new brace or bracket expression, with relevant newlines and indent. "
  (newline)
  (indent-according-to-mode)
  (forward-line -1)
  (indent-according-to-mode))

(use-config smartparens
  (sp-local-pair 'prog-mode "{" nil
                 :post-handlers '((my/indent-between-braces "RET"))))

#+end_src

Automatically highlight the pair opposite to the one at point.

#+begin_src elisp

(use-package paren
  :config
  (show-paren-mode))
  
#+end_src

*** Snippets/Yasnippet
Snippets are reusable fragments of text that can be saved and later inserted into files or buffers. They serve to aviod having to retype commonly used structures.

I use yasnippet which works by expanding abbreviations to predefined templates. These abbreviations are most commonly expanded by pressing the =<TAB>= key when the point is situated behind them, but can also be triggered through other means. (eg. an NCS search)

Templates may also be automatically created by other extensions, such as company-lsp which uses yasnippet templates for parameter expansion.

#+begin_src elisp

(use-package yasnippet
  :straight t
  :defer t
  :config
  (yas-global-mode 1)
  (evil-set-initial-state 'snippet-mode 'insert))

(use-package ivy-yasnippet
  :straight t
  :after yasnippet
  :config
  (setq ivy-yasnippet-new-snippet yas-new-snippet-default))

#+end_src

Yasnippet snippets are generally stored as single files of directories corresponding to the mode they should be used in.

Because of no-littering this structure is located in [[file:etc/yasnippet/snippets]]

I define some custom snippets, most notably:
+ org-mode :: replacements for common org-tempo commands

I also bind the most common yasnippet commands to more easily acessible bindings.

#+begin_src elisp
(general-define-key
 "<f1>" 'yas-new-snippet
 "<f2>" (key-defun yas-dired (dired yas/root-directory)))
#+end_src

#+begin_src elisp
(let ((yas-abort (key-defun yas-abort
                   (my/delete-window-or-kill-buffer t)
                   (message "[yas-snippet]: aborting snippet"))))
  (general-define-key
   :keymaps 'snippet-mode-map
   "<f1>" 'yas-load-snippet-buffer-and-close
   "<f2>" yas-abort
   "C-c C-c" 'yas-load-snippet-buffer-and-close
   "C-c C-k" yas-abort))
#+end_src

*** Jumping
I use avy for jumping to arbitrary characters.
Avy also offers some integration with other constructs and modes (notably lispy).
Evil additionally provides motions for all default avy commands.

I used to bind =s= to =evil-avy-goto-char= and =SPC= to =evil-avy-goto-word-or-subword-1=, but now I just use =evil-avy-goto-word-or-subword-1= on =s=.

#+begin_src elisp

(use-package avy
  :straight t
  :config
  (setq avy-case-fold-search nil))

(general-define-key
 :states '(normal visual)
 "s" 'evil-avy-goto-word-or-subword-1
 "S" nil)

#+end_src

*** Expand-region
Expand-region is an Emacs package that exports one central command =er/expand-region=. It intelligently expands your current region to the next semantic construct.

While it has some integration with specific major modes (eg. org-mode) most of its power comes from the fact that it works well with generic constructs used in most buffers.

I globally bind it to =C-0= and =+= in normal mode for easy access.
I also used to bind normal =-= to =er/cotract-region=, but that does not work with manually set regions and thus is pretty useless.
#+begin_src elisp

(use-package expand-region
  :straight t
  :commands er/expand-region)

(general-define-key
 "C-0" 'er/expand-region)

(general-define-key
 :states '(normal visual)
 "+" 'er/expand-region
 ;;"-" 'er/contract-region
 )

#+end_src

** Programming
*** Defaults
This subtree contains sensible defaults for coding/writing.
Different major modes may override these.

Tabs are 4 spaces.
#+begin_src elisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
#+end_src

Never truncate lines. (May be overriden by =visual-line-mode=)
Custom-mode relies on truncating lines.
#+begin_src elisp
(setq-default truncate-lines t)
(add-hook 'custom-mode-hook (lambda () (setq-local truncate-lines nil)))
#+end_src

*** LSP/DAP family
Lsp-mode is a emacs package that handles talking to language servers supporting Microsofts open-source language server protocol.
It then provides several interfaces to the intelligent code information provided by these servers.
Some of the more generic interfaces are provided by the core lsp-mode package, while others reside in external packages such as lsp-ui and company-lsp.
Some languages may need additional packages for LSP support. These are managed in their respective subtrees.

#+begin_src elisp

(use-package lsp-mode
  :straight t
  :after projectile
  :commands lsp
  :init
  (setq lsp-prefer-flymake :none))

(use-package lsp-ui
  :straight t
  :after lsp-mode
  :init
  ;; disable all frontends by default
  (setq lsp-ui-doc-enable nil)
  (setq lsp-ui-imenu-enable nil)
  (setq lsp-ui-peek-enable nil)
  (setq lsp-ui-sideline-enable nil)
  (setq lsp-ui-flycheck-enable nil))

(use-package company-lsp
  :straight t
  :after (lsp-mode company yasnippet))

#+end_src

DAP is another protocol designed by Microsoft for its Visual Code editor. It functions similarly to the LSP, but is instead designed for debuggers.
Dap-mode for Emacs is also maintained by the emacs-lsp organization.
The project is currently in an early stage of development.

#+begin_src elisp

(use-package dap-mode
  :straight t
  :after lsp-mode)

#+end_src

LLDB support currently requires manual intervention. [TODO: LLDB for DAP]
*** Projectile
Projectile is the de-facto standard project management library for emacs.
It has support for detecting most VC and build systems by default but can be customized further to fit specific workflows.

While projectile has a great user-facing API, some packages in the Emacs ecosystem also call into the library for context on the currently edited projects. (eg. LSP)

Projectile heavily relies on completion for its user-facing API and has builtin support for all NCFs through completion-in-region. Moreover there also exist some packages with additional user commands, optimized for the use with specific NCFs. I prefer ivy and counsel-projectile.

#+begin_src elisp

(use-package projectile
  :straight t
  :config
  (projectile-mode 1))

(use-package counsel-projectile
  :straight t
  :after (projectile counsel)
  :config
  (counsel-projectile-mode))

(use-config projectile
  (setq projectile-completion-system 'ivy))

#+end_src

As previously mentioned, projectile has great support for automatically finding projects based on VC and/or build-root files. It also handles nested repositories.
However I mostly find these features to be annoying for actual day-to-day use.
Therefore I configure projectile to
1) only detect some common VC systems
2) only index the first project and not care about nesting

#+begin_src elisp

(use-config projectile
  (setq projectile-project-root-files-functions '(projectile-root-top-down))
  (setq projectile-project-root-files
        '(".git" ".bzr" ".svn" ".hg" "_darcs" ".projectile"))) 

#+end_src

Bind the default projectile map to the =C-x p= prefix.

#+begin_src elisp
(use-config projectile
  (general-define-key
    "C-x p" projectile-command-map))
#+end_src

*** Direnv
Direnv is a tool for managing directory-local environment variables through =.envrc= files that are automatically detected by the tool.
Allthough initially a shell-oriented tool, there is a third-party package that brings its functionality to Emacs.

It also has great support for =nix= through use of the =use_nix= statement.

#+begin_src elisp
(use-package direnv
  :straight t
  :config
  (direnv-mode 1))
#+end_src

**** ad-hoc
Ad-hoc is a wrapper arround direnv written by me that enables loading of ad-hoc nix environments by writing variables to a default.nix file and then loading the enironment of the directory containing it.

If it becomes more complex, I should probably split it into a separate package.

NOTE: if you want to use this yourself, currently ad-hoc turns off direnv-mode when it is active, as it otherwise tries to reset the variables.
Run =ad-hoc-env-exit= to resume normal operation (this also reenables direnv-mode if it was enabled when =ad-hoc-env-enter= was run).
Enabling/disabling direnv-mode while in an ad-hoc environment is currently not supported. Again, please just run =ad-hoc-env-exit= first.
NOTE:

Using this code also requires you to manually create all of the directories specified in the =ad-hoc-direnv-*-dir= variables.

Contents of .envrc:
#+begin_src sh :tangle no
use_nix
#+end_src

#+begin_src elisp

(defvar ad-hoc-direnv-directory
  (f-join user-emacs-directory ".direnv"))

(defvar ad-hoc-direnv-active-directory
  (f-join ad-hoc-direnv-directory "active"))

(defvar ad-hoc-direnv-inactive-directory
  (f-join ad-hoc-direnv-directory "inactive"))

(defun ad-hoc-write (string)
  (write-region
   (format "
with import <nixpkgs> {};
stdenv.mkDerivation {
  name = \"env\";
  buildInputs = [%s];
}" string)
   nil
   (f-join ad-hoc-direnv-active-directory "default.nix")))

;; TODO: rewrite this for async loading

(defun ad-hoc-update (string)
  (ad-hoc-write string)
  (message "ad-hoc: Waiting for direnv (C-g to cancel)")
  (direnv-update-directory-environment ad-hoc-direnv-active-directory t))

;; TODO: rewrite this as a global minor mode

(defun ad-hoc-env-enter ()
  (interactive)
  (if (bound-and-true-p direnv-mode)
      (setq ad-hoc-direnv-was-enabled t)
    (setq ad-hoc-direnv-was-enabled nil))
  (setq ad-hoc-in-env t)
  (direnv--disable)
  (ad-hoc-update (read-string "packages: ")))

(defun ad-hoc-env-exit ()
  (interactive)
  (unless (bound-and-true-p ad-hoc-in-env)
    (user-error "ad-hoc-env: Not in ad-hoc environment"))
  (setq ad-hoc-in-env nil)
  (if ad-hoc-direnv-was-enabled
      (direnv--enable)
    (direnv-update-directory-environment ad-hoc-direnv-inactive-directory)))

#+end_src

*** Company
Company is the most popular replacement for Emacs' built in auto-complete library and the de-facto default solution for autocompletion in Emacs.
Its main selling points include the ability to perform asynchronous completion and its separation into completion front- and backends.
Some company sources also provide parameter expansion using the yasnippet minor mode.
Other packages may define arbitrary completion backends for company. These are managed in their respective subtrees.

Company is automatically enabled in all programming buffers. Yasnippet is needed for parameter expansion.

#+begin_src elisp

(use-package company
  :straight t
  :defer t
  :hook (((prog-mode text-mode) . company-mode)
         (company-mode . yas-minor-mode)))

#+end_src

Misc company setting, mostly related to frontend display.

#+begin_src elisp

(use-config company
  (setq company-minimum-prefix-length 1)
  (setq company-idle-delay 0.2)
  (setq company-dabbrev-downcase nil)
  (setq company-dabbrev-ignore-case nil)
  (setq company-require-match nil)
  (setq company-tooltip-align-annotations t)
  (setq company-frontends '(company-tng-frontend
                            company-pseudo-tooltip-frontend
                            company-echo-metadata-frontend)))

(general-define-key
 :keymaps 'company-active-map
 :states nil
 "RET" nil
 "<return>" nil
 ";" 'company-complete
 "<tab>" 'company-select-next
 "<backtab>" 'company-select-previous
 "C-y" 'company-complete)

#+end_src

*** Outline/shine                                                   :ARCHIVE:
Outline is a library for structuring files using nested headings that can be folded. It is most famously used by the org-mode extension.

Outshine is a package that promises to bring the advantages of structuring your files with outline to all programming languages.

I personally only use it for Elisp and would like to remove it as soon as possible, because it is very unstable and requires intrusive hacks in order to work properly.

#+begin_src elisp :tangle no
(use-package outshine
  :straight t
  :after org
  :hook (emacs-lisp-mode . outshine-mode))
#+end_src

#+begin_src elisp :tangle no

(defun my/outshine-smart-tab ()
  (interactive)
  (if (outline-on-heading-p)
      (outshine-cycle)
    (indent-for-tab-command)))

;; terrible hack to keep font-lock after reload
(use-config outshine
  (ignore-errors
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (if (bound-and-true-p outshine-mode)
            (font-lock-add-keywords nil (outshine-fontify-headlines (outshine-calc-outline-regexp)))
          (outshine-font-lock-flush))))))

;; use same colors as org-mode
(use-config outshine
  (set-face-attribute 'outshine-level-1 nil :inherit 'org-level-1)
  (set-face-attribute 'outshine-level-2 nil :inherit 'org-level-2)
  (set-face-attribute 'outshine-level-3 nil :inherit 'org-level-3)
  (set-face-attribute 'outshine-level-4 nil :inherit 'org-level-4)
  (set-face-attribute 'outshine-level-5 nil :inherit 'org-level-5)
  (set-face-attribute 'outshine-level-6 nil :inherit 'org-level-6)
  (set-face-attribute 'outshine-level-7 nil :inherit 'org-level-7)
  (set-face-attribute 'outshine-level-8 nil :inherit 'org-level-8))

#+end_src
.
*** Flycheck
Flycheck is an alternative to the builtin flymake. It offers asyncronous buffer syntax checking with good support for external tools.

Languages or extensions may need their own additions to flycheck. These are managed in their respective subtrees.

#+begin_src elisp
(use-package flycheck
  :straight t
  :defer t)
#+end_src

*** Fly/Ispell
Ispell is the most common spell checking utility on unix-like systems.
Emacs ispell offers integration with the program by calling it on some, usually a buffers, text and then walking through all reported errors.

#+begin_src elisp
(use-package ispell
  :defer t)
#+end_src

Flyspell offers more traditional "red underline" spell-checking using Emacs ispell as its backend.

#+begin_src elisp
(use-package flyspell
  :straight t
  :defer t)
#+end_src

Flyspell can be very slow at times. These settings supposedly improve its performance.

#+begin_src elisp
(use-config flyspell
  (setq flyspell-duplicate-distance 0)
  (setq flyspell-issue-message-flag nil))
#+end_src

The command used for spell checking can be changed. I personally use hunspell, which has better support for some languages and is also used by the LibreOffice project.

#+begin_src elisp
(setq ispell-program-name "hunspell")
#+end_src

Currently for me running an ispell/flyspell command for the first time in a session results in an inexplicable type error.

I mitigate this problem by running =ispell-change-dictionary "default"= wrapped in an =ignore-errors= form whenever ispell is loaded. [HACK]

#+begin_src elisp
(use-config ispell
  (ignore-errors
    (ispell-change-dictionary "default")))
#+end_src

**** Dictionaries
The language to spell-check for will usually be set as a file-local variable.
If not, default to "en_US".

#+begin_src elisp
(setq ispell-dictionary "en_US")
(setq flyspell-default-dictionary "en_US")
#+end_src

Using ispell with hunspell requires some additional setup to correctly handle dictionaries.

#+begin_src elisp

;; TODO: more dictionaries
(setq my/ispell-wanted-dictionary-list
      '("en_US" "de_AT"
        "en_US,de_AT"))

(setq ispell-dictionary-alist
      (-map (lambda (dict) `(,dict
	                          "[[:alpha:]]" "[^[:alpha:]]" "[']"
	                          nil ("-d" ,dict)
	                          nil utf-8))
            my/ispell-wanted-dictionary-list))

#+end_src

** Languages
*** Emacs Lisp
Emacs Lisp is a Lisp dialect used mainly as a scripting and configuration language for GNU Emacs and most other Emacs variants.

As Emacs Lisp is the only Lisp dialect I regularly use, this subtree also contains settings that affect general Lisp editing.

Lispy is a package that provides an improved Lisp editing experience.
It is a spiritual successor to the popular paredit.

#+begin_src elisp

(use-package lispy
  :straight t
  :defer t
  :hook (emacs-lisp-mode . lispy-mode))

(use-package lispyville
  :straight t
  :after lispy
  :config
  (require 'lispyville))

(general-define-key
 :definer 'minor-mode
 :keymaps 'lispy-mode
 :states 'insert
 "<backspace>" 'lispy-delete-backward)

(general-define-key
 :definer 'minor-mode
 :keymaps 'lispy-mode
 :states '(normal visual)
 "x" 'lispyville-delete-char-or-splice
 "d" 'lispyville-delete
 "D" 'lispyville-delete-line
 "c" 'lispyville-change
 "C" 'lispyville-change-line
 "y" 'lispyville-yank
 "Y" 'lispyville-yank-line)

#+end_src

Aggressive-indent automatically updates indentation after every keystroke, for instant visual feedback.
This is especially useful for Lisp, where most code structure is determined by indentation.

#+begin_src elisp
(use-package aggressive-indent
  :straight t
  :defer t
  :hook (lispy-mode . aggressive-indent-mode))
#+end_src

*** Haskell
Haskell is a statically typed, /"purely functional"/ general-purpose programming language.

*** Nix
Nix is a functional-style programming language that can be used for package management through the Nix package manager as well as for system configuration through the NixOS project.

NixOS is my preferred GNU/Linux distribution for desktop and server use.
Most of my systems currently run it.

The Nix project also provides an Emacs major mode for working with the Nix language.

#+begin_src elisp
(use-package nix-mode
  :straight t
  :defer t
  :mode "\\.nix\\'")
#+end_src

*** TeX/LaTeX
TeX is a typesetting system developed mainly by Donald Knuth.
LaTeX is the most popular macro collection for TeX. It can be customized further through additional packages.

AucTeX is a popular Emacs extension that majorly improves the editing of TeX files and also provides various other TeX related utilities. I override its package because of the following [[https://github.com/raxod502/straight.el/issues/240][issue]] that affects non-standard GNU Elpa packages.

#+begin_src elisp

(use-package tex
  :straight (auctex :type git :host github 
                    :repo "emacs-straight/auctex")
  :defer t
  :hook
  (TeX-mode . visual-line-mode)
  (LaTeX-mode . visual-line-mode)
  :config
  (TeX-source-correlate-mode)
  (TeX-PDF-mode))

#+end_src

Set Zathura as the default pdf viewer for TeX. This setup allows using source-correlate through SyncTeX.

#+begin_src elisp
(use-config tex
  (add-to-list 'TeX-view-program-selection
               '(output-pdf "Zathura"))
  
  (add-to-list 'TeX-expand-list
               '("%sn" (lambda () server-name)))
  
  (add-to-list 'TeX-view-program-list
               '("Zathura"
                 ("zathura %o"
                  (mode-io-correlate " --synctex-forward %n:0:%b -x \"emacsclient --socket-name=%sn --no-wait +%{line} %{input}\""))
                 "zathura")))
#+end_src

I prefer managing my LaTeX compilation using latexmk and putting all output files into an =out= subdirectory.
This conflicts with the default SyncTeX setup that expects both the output pdf as well as the synctex.gz archive to be in the same directory as the compiled TeX file.
So I override the =TeX-view= command.
[TODO: add el-patch-abstraction]

#+begin_src elisp

(el-patch-feature tex-buf)

(use-config tex-buf
  (el-patch-defun TeX-view ()
    "Start a viewer without confirmation.
The viewer is started either on region or master file,
depending on the last command issued."
    (interactive)
    (let ((output-file (el-patch-swap (TeX-active-master (TeX-output-extension))
                                      (f-join "out" (TeX-active-master (TeX-output-extension))))))
      (if (file-exists-p output-file)
	      (TeX-command "View" (el-patch-swap 'TeX-active-master
                                             (lambda (&rest _)
                                               output-file))
                       0)
        (message "Output file %S does not exist." output-file)))))

#+end_src

*** Markdown
Markdown is a generally well supported loose standard for rich text formatting.

Markdown-mode provides a mode for editing generic Markdown files as well as another for the customized variant supported by Github.

#+begin_src elisp
(use-package markdown-mode
  :straight t
  :defer t
  :hook (markdown-mode . visual-line-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "markdown"))
#+end_src

*** Python
Python is an easy to understand, duck-typed general purpose scripting and programming language.

I just use it for basic scripting, so the builtin python-mode is sufficient for now.

*** Rust
Rust is a modern statically typed systems programming language with support for many high-level concepts currently backed by Mozilla.

The Rust major mode adds basic highlighting and indentation support for the Rust language, while cargo adds integration with the Cargo build-tool.

#+begin_src elisp

(use-package rust-mode
  :straight t
  :mode "\\.rs\\'") ;; this is already done by rust-mode

(use-package flycheck-rust
  :straight t
  :after rust-mode
  :hook (flycheck-mode . flycheck-rust-setup))

(use-package cargo
  :straight t
  :after rust-mode
  :hook (rust-mode . cargo-minor-mode))

#+end_src

#+begin_src elisp

(el-patch-feature cargo-process)

;; (defcustom cargo-process--custom-path-to-bin
;;   (el-patch-swap
;;     (or (executable-find "cargo")
;;         (expand-file-name "cargo" "~/.cargo/bin")
;;         "/usr/local/bin/cargo")
;;     nil)
;;   "Custom path to the cargo executable"
;;   :type 'file
;;   :group 'cargo-process)

;; (defcustom cargo-process--rustc-cmd
;;   (el-patch-swap
;;     (or (executable-find "rustc")
;;         (expand-file-name "rustc" "~/.cargo/bin")
;;         "/usr/local/bin/rustc")
;;     nil)
;;   "Custom path to the rustc executable"
;;   :type 'file
;;   :group 'cargo-process)

(use-config cargo-process
  (el-patch-defun cargo-process--start (name command &optional last-cmd opens-external)
    "Start the Cargo process NAME with the cargo command COMMAND.
OPENS-EXTERNAL is non-nil if the COMMAND is expected to open an external application."
    (set-rust-backtrace command)
    (let* ((buffer (concat "*Cargo " name "*"))
           (project-root (cargo-process--project-root))
           (cmd
            (or last-cmd
                (cargo-process--maybe-read-command
                 (cargo-process--augment-cmd-for-os opens-external
                                                    (mapconcat #'identity (list (el-patch-swap
                                                                                  cargo-process--custom-path-to-bin
                                                                                  (executable-find "cargo"))
                                                                                command
                                                                                (manifest-path-argument name)
                                                                                cargo-process--command-flags)
                                                               " ")))))
           (default-directory (or project-root default-directory)))
      (save-some-buffers (not compilation-ask-about-save)
                         (lambda ()
                           (and project-root
                                buffer-file-name
                                (string-prefix-p project-root (file-truename buffer-file-name)))))
      (setq cargo-process-last-command (list name command cmd))
      (let ((default-directory (or (cargo-process--workspace-root)
                                   default-directory)))
        (compilation-start cmd 'cargo-process-mode (lambda(_) buffer)))
      (set-process-sentinel (get-buffer-process buffer) 'cargo-process--finished-sentinel)))

  (el-patch-defun cargo-process--workspace-root ()
    "Find the workspace root using `cargo metadata`."
    (when (cargo-process--project-root)
      (let* ((metadata-text (shell-command-to-string
                             (concat (el-patch-swap
                                       cargo-process--custom-path-to-bin
                                       (executable-find "cargo"))
                                     " metadata --format-version 1 --no-deps")))
             (metadata-json (json-read-from-string metadata-text))
             (workspace-root (cdr (assoc 'workspace_root metadata-json))))
        workspace-root))))

#+end_src

*** Scheme
Geiser is an interaction mode similar to SLIME but for Scheme-like languages.
General highlighting/indentation support is provided by Emacs.

#+begin_src elisp

(use-package geiser
  :straight t
  :defer t
  :config
  (setq geiser-repl-save-debugging-history-p t))


(general-define-key
 :keymaps 'geiser-repl-mode-map
 "C-d" 'my/delete-window-or-kill-buffer)

#+end_src

*** TODO Shell
** Misc
*** Calculator/Calc
I don't really know how to use Emacs' builtin calc calculator yet.
[[https://github.com/ahyatt/emacs-calc-tutorials][Here]] is a set of seemingly very competent tutorials for it.

For now, bind the main =calc= command to =C-x c=.

#+begin_src elisp
(general-define-key
  "C-x c" 'calc)
#+end_src

Also enable evil-integration.

#+begin_src elisp
(use-config (calc evil-collection)
  (evil-collection-calc-setup))
#+end_src

*** REPL/Comint
Comint is an Emacs library/mode that is used by other packages that want to define REPL-style interfaces. For example, SLIME, geiser and SQL-mode are all based on comint.
By correctly configuring comint I ensure that all of these interfaces operate the way I like.

I want all my REPLs to use readline-like bindings for most common operations so I don't get confused when switching between Emacs and Bash/Zsh.

Some of these might be overriden by specific comint-derived modes, this is then managed in their respective buffers.

#+begin_src elisp

(general-define-key
 :keymaps 'comint-mode-map
 "C-l" 'comint-clear-buffer
 "<up>" 'comint-previous-input
 "<down>" 'comint-next-input
 "C-r" 'comint-history-isearch-backward
 "C-d" 'my/delete-window-or-kill-buffer
 "C-c" 'comint-interrupt-subjob)

#+end_src

Smartparens messes with the editing model of lisp repls (geiser, SLIME) which expect you to manually insert parentheses, so I disable it for all comint-derived modes.

#+begin_src elisp
(add-hook 'comint-mode-hook (lambda () (smartparens-mode -1)))
#+end_src

*** Files/Dired
Dired is an Emacs mode for editing directories. It shows the output of =ls -l= which can then be acted upon.

Dired is also very extensible through custom keybindings and extensions, which I use quite a lot of.

#+begin_src elisp

(use-package dired
  :defer t
  ;; most of these bindings are overriden later
  :config
  (setq dired-mode-map (make-sparse-keymap))
  (evil-collection-dired-setup))

(use-config dired
  (setq dired-listing-switches "-alhv")
  (setq dired-recursive-copies 'always)
  (setq dired-dwim-target t))

#+end_src

#+begin_src elisp

;; use evil even without evil-collection
(add-hook 'dired-mode-hook 'evil-normal-state)

(general-define-key
 :keymaps 'dired-mode-map
 :states '(visual normal)
 "f" 'find-file
 "v" 'evil-visual-line

 "n" 'dired-next-marked-file
 "N" 'dired-prev-marked-file

 "H" 'dired-hide-details-mode
 "W" (lambda ()
       (interactive)
       (wdired-change-to-wdired-mode)
       (evil-normal-state) (forward-char))

 "<backspace>" 'dired-up-directory
 "<RET>" 'dired-find-file

 "q" 'quit-window)

(general-unbind
 :keymaps 'dired-mode-map
 :states 'visual
 "k" "j")

#+end_src

**** Extensions

Dired+ is an collection of different dired extensions, some of which are more useful (and less completely broken) than others.

Dired+ automatically activates most of its keybindings when first loaded.
Additionally, I bind the =image-dired= command to =C-t C-r=

#+begin_src elisp

  ;; FIXME: I dont know what this does
  (setq dired-omit-files "idontfuckingknow")

  (use-package dired+
    :straight (dired+
               :type git :host github
               :repo "emacsmirror/emacswiki.org"
               :files ("dired+.el"))
    :after dired
    :init
    ;; setup evil and add missing lazy binds
    (evil-collection-image-dired-setup))

  (general-define-key
   :keymaps 'image-dired-thumbnail-mode-map
   :states 'normal
   "<left>" 'image-dired-backward-image
   "<right>" 'image-dired-forward-image
   "<up>" 'image-dired-previous-line
   "<down>" 'image-dired-next-line)

#+end_src

Image-dired is an additional mode provided by dired+ which allows for viewing image thumbnails in a separate buffer.
It als offers in-dired thumbmail display bound to =C-t C-t=.

#+begin_src elisp

(general-define-key
 :keymaps 'dired-mode-map
 :states '(normal visual insert emacs)
 "C-t" (cdr (assoc 20 image-dired-minor-mode-map))
 "C-t C-t" 'image-dired-dired-toggle-marked-thumbs
 "C-t C-r" 'image-dired)

(evil-set-initial-state 'image-dired-minor-mode 'emacs)

#+end_src

Diredfl is a package that extracts the improved highlighting offered by dired+ and presents it in a more modern (and more importantly, not completely broken) way.

#+begin_src elisp

(use-package diredfl
  :straight t
  :after dired
  :config
  (diredfl-global-mode))

#+end_src

Dired-filter is a practical extension to dired which allows for either marking or hiding files that match a set of combineable criteria.
It also offers creating groups based on these criteria, which I do not use.

#+begin_src elisp

(use-package dired-filter
  :straight t
  :after dired
  :hook (dired-mode . dired-filter-mode))

#+end_src

Dired filter provides some convenient maps for marking and filtering, I bind them to =M= and =F= respectivly.

#+begin_src elisp

(general-define-key
 :keymaps 'dired-mode-map
 :states '(normal visual)
 "F" dired-filter-map
 "M" dired-filter-mark-map)

#+end_src

Dired-ranger is an extension offers some improvements to make dired feel more like the ranger terminal file manager.
I mainly use its copy and paste functionality.

#+begin_src elisp

(use-package dired-ranger
  :straight t
  :after dired)

#+end_src

Dired-ranger does not provide any keybindings itself, so I bind the most important functionality here.

#+begin_src elisp

(general-define-key
 :keymaps 'dired-mode-map
 :states '(normal visual)
 "y" 'dired-ranger-copy
 "a" (key-fun dired-ranger-copy t)
 "pc" 'dired-ranger-paste
 "pm" 'dired-ranger-move

 "U" (lambda ()
       (interactive)
       (dired-unmark-all-marks)
       (ring-remove dired-ranger-copy-ring 0)))

(general-define-key
 :keymaps 'dired-mode-map
 :states 'visual
 "u" 'diredp-unmark-region-files
 "y" (lambda ()
       (interactive)
       (call-interactively 'dired-mark)
       (dired-ranger-copy nil))
 "a" (lambda ()
       (interactive)
       (call-interactively 'dired-mark)
       (dired-ranger-copy t)))

#+end_src

Both dired-filter and dired-ranger are maintained by the dired-hacks project.


Dired-quick-sort is another package that aims to improve the process of easily finding the files you need by offering a hydra menu that gives access to most relevant ways of sorting files.

#+begin_src elisp
(use-package dired-quick-sort
  :straight t
  :after dired)
#+end_src

I bind the menu to =o=.

#+begin_src elisp

(general-define-key
 :keymaps 'dired-mode-map
 :states '(normal visual)
 "o" 'hydra-dired-quick-sort/body)

#+end_src

Despite its name, org-download also provides drag and drop functionality to dired.
I only use it for this purpose and therefor place its configuration in the [[Files/Dired]] (this) subtree.

#+begin_src elisp

(use-package org-download
  :straight t
  :defer t
  :hook (dired-mode . org-download-enable))

#+end_src

*** Diff/Ediff
Ediff is Emacs' builtin tool for viewing file diffs.
It has got some pretty suboptimal defaults and keybindings, so I set some of my preferences and enable evil integration here.

#+begin_src elisp

(use-config ediff
  (evil-collection-ediff-setup))

(use-config ediff
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-diff-options "-w")
  (add-hook 'ediff-prepare-buffer-hook #'show-all))

#+end_src

*** Git/Magit
Git is the most common VC system today.
Most open-source project use it, partly because of its great hosting support with Github and Gitlab providing near-unlimited public storage.

Magit is an intuitive and comprehensive graphical interface to the git CLI.
It is widely considered the best currently existing git client.

I bind the main interface to =C-x g= for easy access.

#+begin_src elisp

(use-package magit
  :straight t
  :defer t)

(use-package evil-magit
  :straight t
  :after (magit)
  :config
  (evil-magit-init)
  ;; writing commit messages is usually a pretty quick process, so I would like to start in insert state.
  (evil-set-initial-state 'git-commit-mode 'insert))

(general-define-key
 :prefix "C-x"
 "g" 'magit-status)

#+end_src

More recently Magit also gained support for working with git forges through the additional "forge" package.
In order to correctly install and use magit-forge, you will need to have a C compiler (eg. gcc) when first running any forge command. [TODO: this is suboptimal]

I currently disable this package, as it still is somewhat buggy and I don't really use it.

#+begin_src elisp
;; (use-package forge
;;   :straight (forge :type git :host github
;;                    :repo "magit/forge")
;;   :after magit)
#+end_src

*** Help
Simply enable evil integration for help-mode.

#+begin_src elisp
(use-config evil-collection
  (evil-collection-help-setup))
#+end_src

*** Images/Image
Image-mode is a mode used for displaying bitmap images in Emacs.

Like with most no-self-insert-modes, I want =q= to close the window and buffer.

#+begin_src elisp
(general-define-key
 :keymaps 'image-mode-map
 "q" 'my/delete-window-or-kill-buffer)
(evil-set-initial-state 'image-mode 'emacs)
#+end_src

*** Music/MPD
MPD is an daemon for playing music.
Many frontends for the MPD server exist, I use ncmpcpp for terminal and mpdel for Emacs. There's also ivy-mpdel which allows for using the ivy NCS to select songs.

#+begin_src elisp

(use-package mpdel
  :straight t
  :defer t)

(use-package ivy-mpdel
  :straight t
  :after mpdel)

#+end_src

*** TODO Mail
Emacs is, in my opinion, the best MUA currently out there.

This is my current setup for mail in Emacs:
+ Sending
  + message-mode :: easily send mail from an Emacs buffer
  + sendmail.el :: call the external sendmail command from emacs
  + msmtp :: a simple nullclient sendmail alternative (external)
  + postfix :: a powerful mail server, can be used as a nullclient or relay server (external)
+ Sync
  + mbsync :: a faster alternative to the well know offlineimap (external)
+ Reading
  + notmuch :: a fast tag-based mail indexer - has an Emacs frontend

Alternative readers:
+ gnus :: gnus is the default Emacs mail reader. It's good but hard to configure
+ mu4e :: mu4e is the Emacs frontent for mu, another mail indexer similar to notmuch
+ wanderlust :: idk, apparently very badly documented
+ mew :: idk

**** Message
Message-mode automatically reads, updates and then sends the contents of a buffer with a correctly formatted mail header.

The way the mail is send can be customized using the =message-send-mail-function= variable. I prefer just calling an external command over using the synchronous elisp sendmail implementation.

#+begin_src elisp
(setq message-send-mail-function 'message-send-mail-with-sendmail
      send-mail-function 'sendmail-send-it)
#+end_src

While we're at it, also configure sendmail.

#+begin_src elisp

;; substitute sendmail with msmtp
(setq sendmail-program "msmtp")

;; allow setting account through email header
(setq message-sendmail-extra-arguments '("--read-envelope-from"))
(setq message-sendmail-f-is-evil t)

#+end_src

Message mode for some reason associates a file with new message buffers.
This causes problems with my modeline (doom) and also seems like a bad idea in general, so I unset the buffers file when message-mode is enabled.

#+begin_src elisp
(add-hook 'message-mode-hook
          (lambda nil
            (rename-buffer (f-filename (buffer-file-name)))
            (setf (buffer-file-name) nil)
            (set-buffer-modified-p nil)
            (force-mode-line-update)))
#+end_src

#+begin_src elisp

(add-hook 'message-send-hook
          (lambda ()
            (unless (y-or-n-p "Sure you want to send this?")
              (signal 'quit nil))))

#+end_src

**** Notmuch
*** Org
Org is a system for keeping easily navigable plain text notes, lists, and structured documents.
It also features literate programming support through org-babel, which this document uses for exporting, a customizable agenda, the ability to easily capture arbitrary text without interrupting your workflow and a large amount of export backends, ranging from LaTeX documents to complex static webpages.
There exist a huge amount of extensions to the Org system which can be loaded as normal Emacs packages from repositories such as MELPA or ELPA.
I have also written one of my own, [[file:straight/repos/org-pretty-jump/][org-pretty-jump]].

In no particular order, these are some of the things I use:
+ Easy buffer navigation and editing
  + org-tempo (builtin but not loaded by default)
  + worf
  + org-pretty-jump goto
  + custom keybindings
+ Authoring notes
  + TODO keywords and states
  + org-capture
    + org-protocol
    + org-pretty-jump capture
  + org-agenda
  + refile
    + org-pretty-jump refile
+ Writing papers/articles
  + org-ref
  + export to LaTeX
    + Bib(La)TeX support
+ Writing documentation
  + Github support (eg. README.org)
  + export to static page
+ Literate programming
  + org-babel
    + tangle
    + in-buffer evaluation

Officially load the org-plus-contrib package and also require some optional packages.
[TODO: check if this still works]

#+begin_src elisp
(use-package org
  :straight org-plus-contrib
  :requires (org-capture org-protocol))
#+end_src

**** Personal
These are the personal settings I need for managing my notes (as well as my [[RSS/Elfeed]] feeds) on my system.
Even if you want to copy some of my settings, you will almost definitely want to change these.

#+begin_src elisp
(setq org-default-notes-file "~/notes.org")
(setq rmh-elfeed-org-files (list "~/Projects/feeds.org"))

(setq org-todo-keywords
      '((sequence "TODO" "DOING" "|" "DONE BUT" "DONE")
        (sequence "MAYBE" "CANCELED" "|")))
#+end_src

***** Link types
These are my custom org-link-types.

#+begin_src elisp
(use-config org
  (org-add-link-type
   "project" 'projectile-switch-project-by-name))
#+end_src

***** Capture templates
These are my custom org-capture templates.
Probably only "g - Generic" stands out. It uses org-pretty-jump to capture to an arbitrary subtree in my =org-default-notes-file=.
"L - Protocol Link" and "p - Protocol Selection" are used by org-protocol and the org-capture firefox extension.

#+begin_src elisp
(setq org-capture-templates
      '(("g" "Generic" entry
         (file+function "" (lambda ()
                             (goto-char (opj/get-heading-pos t))))
         "* %?%i")
        ("L" "Protocol Link" entry (file+headline org-default-notes-file "Weblinks")
         "* %:description%?\n[[%:link]]\n%t"
         :immediate-finish t)
        ("p" "Protocol Selection" entry (file+headline org-default-notes-file "Weblinks")
         "* %:description\n[[%:link]]\n%t\n#+BEGIN_QUOTE\n%i\n#+END_QUOTE\n%?")))
#+end_src

**** Buffer
In order to use org-mode effectively it is important to be able to comfortably manage your .org files and buffers.
I personally enjoy easy to access DWIM keys and menus over having to memorize a large amount of keybindings.
Some of these I have created myself, some are provided by Org.

I enjoy writing prose in visual line mode. Add the required hook here.

#+begin_src elisp
(add-hook 'org-mode-hook 'visual-line-mode)
#+end_src

The default keybindings for =<return>= and =<C-return>= only really work for outline headings. I bind the indentation-aware return to =<return>= and =unpackaged/org-return-dwim= for better list support.

#+begin_src elisp

(general-define-key
 :keymaps 'org-mode-map
 :states 'insert
 "<return>" 'org-return-indent)
 ; TODO: "<C-return>" 'unpackaged/org-return-dwim)

#+end_src

The org-mark ring can be pretty useful, but isn't consistently bound.

#+begin_src elisp
(general-define-key
 :keymaps 'org-mode-map
 "C-k" (key-fun org-mark-ring-goto))
#+end_src

Navigating huge Org buffers can be difficult. org-pretty-jump tries to make that task easier by providing a good-looking ivy-based menu that can be used to jump to any headline.
It also provides some additional functions for common Org task such as refiling as well as an easy to understand API for creating custom actions using the central menu.

#+begin_src elisp

(use-package org-pretty-jump
  :straight (org-pretty-jump :type git :host github
                             :repo "LeOtaku/org-pretty-jump")
  :after org)

(general-define-key
 :states '(normal visual)
 "gh" 'opj-contrib/jump
 "gH" (key-fun opj-contrib/jump 1))

#+end_src

Additionally i define a hydra for navigating between headlines and performing the most common operations on them.

#+begin_src elisp

(defhydra hydra-org-ship (;;
                          :body-pre (progn
                                      (org-mark-ring-push)
                                      (ignore-errors
                                        (org-back-to-heading)))
                          :foreign-keys exit
                          :hint nil
                          :exit nil)
  "
org-ship: _j_, _k_, _l_, _g_ act: _w_, _t_, _T_ exit: _b_, _q_, other"
  ("j" (org-next-visible-heading 1))
  ("k" (org-previous-visible-heading 1))
  ("l" (org-up-heading-all 1))
  ("g" (opj-contrib/jump))
  ("<tab>" (org-cycle))
  ("<backtab>" (progn (org-global-cycle) (org-reveal)))
  ("w" (org-refile))
  ("t" (org-todo))
  ("T" (org-todo '(4)))
  ("b" (org-mark-ring-goto) :exit t)
  ("C-l" (org-mark-ring-goto) :exit t)
  ("q" nil :exit t))

(general-define-key
 :keymaps 'org-mode-map
 "C-l" 'hydra-org-ship/body)

#+end_src

Do not adapt indentation by inserting whitespace. This is better handled by =org-indent-mode=.
#+begin_src elisp
(setq org-adapt-indentation nil)
#+end_src

Org mode already has great highlighting for most important syntax, some common constructs seem to be missing.
This includes both =@@key: text@@= style inline markup, as well as list items.
Additionally I personally enjoy using the =->= symbol in my notes to signal causation, so I would like to see that highlighted.
Add the required entries here.

#+begin_src elisp

(setq my/org-list-font-locks
      '(("^ *\\([0-9]+\\.\\)" 1 'bold)
        ("^ *\\([0-9]+)\\)" 1 'bold)
        ("^ *\\([+-]\\)" 1 'bold)
        ("^ +\\([*]\\)" 1 'bold)))

(setq my/org-misc-font-locks
      '(("\\(->\\)" 1 'bold)
        ("\\(@\\)" 1 'org-meta-line)))

(font-lock-add-keywords 'org-mode my/org-list-font-locks)
(font-lock-add-keywords 'org-mode my/org-misc-font-locks)

#+end_src

Moreover, I would like highlighting for all additional TODO states I may or may not ever use.

#+begin_src elisp

(defface org-bad '((t :foreground "red" :inherit 'org-todo)) "")
(defface org-maybe  '((t :foreground "magenta" :inherit 'org-todo)) "")

(setq org-todo-keyword-faces
      '(("TODO"      . 'org-todo)
        ("DOING"     . 'org-todo)
        ("FUTURE"    . 'org-todo)
        ("DONE BUT"  . 'org-done)
        ("DONE"      . 'org-done)
        ("MAYBE"     . 'org-maybe)
        ("PLANNED"   . 'org-maybe)
        ("CANCELED"  . 'org-bad)
        ("DROPPED"   . 'org-bad)
        ("FAILED"    . 'org-bad)))

#+end_src

Lastly, lets display images by default, but make sure they get scaled sensibly.

#+begin_src elisp
(setq org-image-actual-width 400)
(setq org-startup-with-inline-images t)
#+end_src

**** Links
Custom link types live in =Personal/Link Types=.
These are other link-related settings not specific to my personal setup.

Always link files relatively if possible.
#+begin_src elisp
(setq org-link-file-path-type 'relative)
#+end_src

Always show the shortest candidate first when completing link-types.
#+begin_src elisp
(add-to-list 'ivy-sort-matches-functions-alist
             '(org-insert-link . my/ivy-sort-by-length)
             t)
#+end_src

**** Capture
Capture templates live in =Personal/Capture Templates=.
These are other capture-related settings not specific to my personal setup.

#+begin_src elisp
(use-config (org-capture evil)
  (add-hook 'org-capture-mode-hook (lambda () (evil-append 1))))
#+end_src

Update todo counter when capturing to subtree.

#+begin_src elisp
(use-config org-capture
  (add-hook 'org-capture-before-finalize-hook 'org-update-parent-todo-statistics))
#+end_src

The org-capture menu in my opinion is more complex than it needs to be.
Instead, I use a hydra that simply shows me all capture templates, except for the ones that have "protocol" in their description.

#+begin_src elisp
(defun hydra-org-capture/dynamic ()
  (interactive)
  (funcall (eval `(defhydra hydra-org-capture (;;
                                               :exit t
                                               :foreign-keys exit)
                    "
org-capture: "
                    ,@(--map (let ((char (car it))
                                   (name (cadr it)))
                               `(,char (org-capture nil ,char) ,name))
                             (--filter (not (s-contains? "protocol" (cadr it) t))
                                       org-capture-templates))
                    ("q" nil "exit")))))
#+end_src

I bind it to =C-c c= for easy access.

#+begin_src elisp
(general-define-key
 "C-c c" 'hydra-org-capture/dynamic)
#+end_src

**** Export
The org ecosystem offers many different export backends for a wide range of usecases.

I mainly use the following exporters:
+ LaTeX :: writing documents
+ Hugo :: webpages using the gohugo static site generator
+ Plaintext :: email

These can be accessed using the default =C-c C-e= binding provided by org mode.

Set the LaTeX backend to export to pdf using the =latexmk= utility.

#+begin_src elisp
(use-config org
  (setq org-latex-pdf-process
        (list "latexmk -interaction=nonstopmode -output-directory=%o -shell-escape -bibtex -f -pdf %f")))
#+end_src

Load and configure the external backends.

#+begin_src elisp
(use-package ox-hugo
  :straight t)
#+end_src

**** Org-ref
Org ref is a package that makes it easy to work with Bib(La)TeX bibliographies in .org buffers and files.
It, among other things, provides easy access to ref/cite/label links using either helm or ivy, in-buffer error reporting and automatic link resolution for exports.
It may also be used in conjunction with the ivy/helm-bibtex packages.

#+begin_src elisp

(use-package org-ref
  :straight t
  :after (org ivy-bibtex)
  :requires (doi-utils org-ref-isbn org-ref-ivy org-ref-helm)
  :init
  (setq org-ref-completion-library 'org-ref-ivy-cite)
  (org-ref-ivy-cite-completion))

#+end_src

I don't like the way ivy and helm org-ref-cite display possible citations.
Moreover the system for choosing the correct NCS implementation for org-ref is a broken mess.
Thus I manually set the desired values for the completion functions.

=my/org-ref-ivy-insert-cite-link= works like =org-ref-ivy-insert-cite-link=, but with the prettier formatting of =ivy-bibtex=.

#+begin_src elisp

(defun my/org-ref-ivy-insert-cite-link ()
  (interactive)
  (let ((bibtex-completion-bibliography org-ref-bibliography-files))
    (setq org-ref-ivy-cite-marked-candidates '())

    (ivy-read "Open: " (bibtex-completion-candidates)
	          :require-match t
	          :keymap org-ref-ivy-cite-keymap
	          :re-builder org-ref-ivy-cite-re-builder
	          :action 'or-ivy-bibtex-insert-cite
	          :caller 'my/org-ref-ivy-insert-cite-link)))

(setq org-ref-insert-link-function 'my/org-ref-ivy-insert-cite-link)
(setq org-ref-insert-cite-function 'my/org-ref-ivy-insert-cite-link)
(setq org-ref-insert-label-function 'org-ref-ivy-insert-label-link)
(setq org-ref-insert-ref-function 'org-ref-ivy-insert-ref-link)
(setq org-ref-cite-onclick-function 'org-ref-ivy-onclick-actions)

#+end_src

**** Babel
Org-babel is a system for literate programming with support for many popular languages. I use it to literally configure my Emacs editor.

Don't uselessly split org-src windows.

#+begin_src elisp
(setq org-src-window-setup 'current-window)
#+end_src

Make source code indentation work as expected.

#+begin_src elisp
(setq org-src-preserve-indentation nil
      org-edit-src-content-indentation 0
      ;; TODO: make this work with custom bindings
      org-src-tab-acts-natively t)
#+end_src

Narrowed buffers support automatic saving to their parent buffers. Org-src tries to emulate this functionality but does not consider the evil =:w= command.
Manually add support for it here.

#+begin_src elisp
(advice-add 'evil-write :before-until 'my/advice-evil-write)
(defun my/advice-evil-write (&rest ignore)
  (when (org-src-edit-buffer-p)
    (org-edit-src-save)
    t))
#+end_src

I also bind =C-c C-c= in org-src buffers to emulate org-babel code execution.

#+begin_src elisp
(general-define-key
 :keymaps 'org-src-mode-map
 "C-c C-c" 'eval-buffer)
#+end_src

**** Tangle
Babel-tangle is org-babels builtin way of exporting source blocks to actual code.
It provides a rich syntax for specifing how any specific source block should be tangled.

Unfortunately it is sinfully slow as well as syncronous/blocking, making working with it a chore.
I mitigate this problem by using the great [[https://github.com/OrgTangle/ntangle][ntangle]], which is a near-complete org-tangle replacement written in the Nim language.

For now add a =:before-until= advice to =org-babel-tangle= that tests for the existence of the binary and runs it instead of the default elisp tangle.
This currently does NOT respect any of the arguments passed to =org-babel-tangle=.

A Nix expression for the ntangle tool is provided with this configuration. It lives in the [[file:nix/][nix]] folder in this repository and can easily be installed through =nix-env= in the following fashion:

#+begin_src sh :tangle no
nix-env -f ~/.emacs.d/nix/easy-install.nix -iA ntangle
#+end_src

You may also manually set the path to the correct binary yourself through the =my/org-ntangle-bin= variable.

Using the same mechanism, I also define the =reload-org= command, which acts like my default =reload= command, but tries to retangle the current init file before performing the reload.

#+begin_src elisp

(defvar my/org-ntangle-bin
  (executable-find "ntangle"))

(defun my/org-ntangle-maybe-tangle-file (file)
  (if (and my/org-ntangle-bin (f-exists-p my/org-ntangle-bin))
      (start-process
       ;; name + buffer + cmd
       "org-ntangle-tangle" "*org-ntangle-process*" my/org-ntangle-bin
       ;; arguments
       file)
    nil))

(advice-add 'org-babel-tangle :before-until 'my/advice-org-babel-tangle)
(defun my/advice-org-babel-tangle (&optional arg target-file lang)
  (when (derived-mode-p 'org-mode)
    (if (my/org-ntangle-maybe-tangle-file buffer-file-name)
        (message "org-ntangle-tangle: tried to tangle file")
      (message "org-ntangle-tangle: ntangle binary not found")
      nil)))

(defun reload-org ()
  "Reload init.org with optional straight integration"
  (interactive)
  (if (my/org-ntangle-maybe-tangle-file
       (f-swap-ext user-init-file "org"))
      (progn
        (reload)
        (message (format "org-ntangle-tangle: tried to tangle file + performed reload")))
    (message "org-ntangle-tangle: missing binary")))

#+end_src

*** TODO Reading
**** PDF/pdf-tools
**** EPUB/nov.el
*** RSS/Elfeed
The elfeed package provides an easy to use and configurable RSS reader for Emacs.
Sensible vi-bindings are provided by evil-collection.

You will also have to make sure to have the =curl= binary/application installed to fetch feeds asynchronously.

#+begin_src elisp

(use-package elfeed
  :straight t
  :defer t
  :config
  (evil-collection-elfeed-setup))

#+end_src

I bind the provided =elfeed= command to =C-x w= for easy access.

#+begin_src elisp
(general-define-key
 "C-x w" 'elfeed)
#+end_src

There is also support for specifying your subscriptions/feeds from an Org file through the elfeed-org package.
The default feeds file is set inside the [[Personal]] subtree.

#+begin_src elisp

(use-package elfeed-org
  :straight t
  :after elfeed
  :config
  (elfeed-org))

#+end_src

This system also allows me to easily tag all of my RSS feeds.
For example, I could use the "unimportant" tag to tag feeds I don't necessarily want to see when I'm not specifically searching for them.
In this case I would also set the default =elfeed-search-filter= variable to ignore entries tagged this way.

#+begin_src elisp
(setq-default elfeed-search-filter "@6-months-ago +unread ")
#+end_src

I also define some functional content-type tags that are later used for determining how to handle the posts using my =my/elfeed-search-handle-entry= command.

#+begin_src elisp

(defconst my/elfeed-handler-alist
  '((youtube . my/elfeed-search-mpv-entry-link)
    (web . my/elfeed-search-browse-entry-link)
    (t . elfeed-search-show-entry)))

(defun my/elfeed-search-handle-entry ()
  (interactive)
  (let* ((entry (elfeed-search-selected t))
         (tags (elfeed-entry-tags entry))
         (handler-cons (--first (or (-contains? tags (car it))
                                    (eq (car it) t))
                                my/elfeed-handler-alist)))
    (apply (cdr handler-cons) (list entry))))

(defun my/elfeed-search-browse-entry-link (entry)
  (interactive
   (list (elfeed-search-selected t)))
  (let* ((link (elfeed-entry-link entry)))
    (browse-url link)
    (elfeed-untag-1 entry 'unread)
    (elfeed-search-update-entry entry)))

(defun my/elfeed-search-mpv-entry-link (entry)
  (interactive
   (list (elfeed-search-selected t)))
  (let* ((link (elfeed-entry-link entry)))
    (async-start `(lambda ()
                    (call-process "mpv" nil "*mpv-process*" t ,link))
                 `(lambda (e)
                    (if (= e 0)
                        (message "playing video in external mpv window")
                      (error "playing video in mpv window failed: %s" e))))
    (elfeed-untag-1 entry 'unread)
    (elfeed-search-update-entry entry)))

#+end_src

I then bind some of these handler functions to =<return>=, =<C-return>=, or =<M-return>= respectively.

#+begin_src elisp

(use-config elfeed
  (general-define-key
   :keymaps 'elfeed-search-mode-map
   :states '(normal insert visual emacs)
   "<return>" 'my/elfeed-search-handle-entry
   "<C-return>" 'elfeed-search-show-entry
   "<M-return>" 'my/elfeed-search-browse-entry-link))

#+end_src

I also add some other bindings for convenience.

#+begin_src elisp

(general-define-key
 :keymaps 'elfeed-search-mode-map
 :states '(normal insert visual emacs)
 "d" 'my/elfeed-search-filter-default)

(defun my/elfeed-search-filter-default ()
  (interactive)
  (elfeed-search-set-filter (default-value 'elfeed-search-filter)))

#+end_src

*** TODO IRC/?
*** Scratch
The =*scratch*= buffer automatically gets spawned by Emacs on startup.
It is intended for quick elisp evaluation and testing, but could also serve any other purpose.

By default the scratch buffer starts in lisp-interaction-mode, which only slightly changes the behavior of =eval-print-last-sexp=.
This also enables us to bind scratch-only keybindings. I use =C-c C-c= for quick evaluation.

#+begin_src elisp
(general-define-key
 :keymaps 'lisp-interaction-mode-map
 "C-c C-c" (key-defun eval-buffer
             (message "executing Elisp code buffer...")
             (message "%s" (eval-buffer))))
#+end_src

**** Persistent-scratch                                             :ARCHIVE:
I want my scratch buffer to always be persistent.
To work reliably this system also requires some additional help from =nuke-emacs= in [[Commands]].
[TODO: find an elegant solution to this and crashes]

Scratch is only saved/restored when [[Desktop]] is also enabled, which is only the case for the first running Emacs session.

#+begin_src elisp :tangle no

(use-package persistent-scratch
  :straight t
  :config
  (persistent-scratch-autosave-mode -1))

;; add desktop mode hooks
(use-config (persistent-scratch desktop)
  (add-hook 'desktop-after-read-hook 'persistent-scratch-restore)
  (add-hook 'desktop-save-hook (lambda ()
                                 (when (get-buffer "*scratch*")
                                   (persistent-scratch-save)))))

#+end_src
.
*** Shell-pop
Shell-pop is an Emacs package that allows you to quickly pop up a unix shell in the current directory.
I use it to quickly open up an =ansi-term= terminal when I need one.

#+begin_src elisp

(use-package shell-pop
  :straight t)

(use-config shell-pop
  ;; taken from the Pragmatic Emacs blog
  (setq shell-pop-shell-type (quote ("ansi-term" "*ansi-term*" (lambda nil (ansi-term shell-pop-term-shell)))))
  (setq shell-pop-term-shell (getenv "SHELL"))
  ;; need to do this manually or not picked up by `shell-pop'
  (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))

(general-define-key
 ;; override is needed for adding to "C-a" prefix
 :keymaps 'override
 "C-x t" 'shell-pop
 "C-a t" 'shell-pop)

#+end_src

*** Terminal/Term
Term and ansi-term are compelling alternatives to the classical Emacs shell or eshell functionality.

I bind some keys to emulate the "typical" UNIX-terminal.

#+begin_src elisp

(general-define-key
 ; [TODO] other bindings
 :keymaps '(term-raw-map term-mode-map)
 :states '(insert normal visual emacs)
 ;; dirty shell-pop intergration
 "C-d" (lambda ()
         (interactive)
         (if (string= (buffer-name) shell-pop-last-shell-buffer-name)
             (call-interactively 'shell-pop)
           (my/delete-window-or-kill-buffer)))
 "C-a t" 'shell-pop
 "C-c" 'term-interrupt-subjob
 "C-h" help-map
 "M-x" 'counsel-M-x)

#+end_src

*** TODO Tramp
* Changelog                                                        :noexport:
** Planned [14/35]
*** TODO move lispy and agressive indent out of [[Emacs Lisp]]
*** TODO learn lispy and bind tab + C-l
*** TODO add use-package binary dependecy checks
*** TODO ensure literate-emacs stays modular
*** MAYBE create custom mua
*** TODO improve delete-or-kill with content-aware
*** TODO org-cycle-separator-lines
<2019-04-01 Mon>
*** TODO investigate csetq
<2019-03-30 Sat>
https://oremacs.com/2015/01/17/setting-up-ediff/
*** TODO find out how to get theme-agnostic colors
<2019-03-30 Sat>
*** DONE rework organization arround first headings
<2019-03-27 Wed>
*** DONE yasnippet
<2019-03-27 Wed>
*** DONE investigate general-simulate-keypress
<2019-03-26 Tue>
*** DONE shell-command w/o newline
<2019-03-26 Tue>#
*** TODO org-mode things
<2019-03-26 Tue>
habit, schedule, agenda, clocking
*** DONE keyfreq-mode
<2019-03-26 Tue>
*** TODO ediff
<2019-03-22 Fri>
*** TODO debug-on-error as default
<2019-03-13 Wed>
*** TODO replace unpackaged.el org-return
<2019-03-11 Mon>
Insert new heading below when in heading
*** DONE smart backspace in non prog-mode
<2019-03-05 Tue>
*** DONE BUT persistent scratch
<2019-03-04 Mon>
Bad code. Needs to ensure if =*scratch*= exists.
*** DONE BUT configure SyncTeX
<2019-03-04 Mon>
Inflexible should only error if none in both
*** TODO fix dired bindings
<2019-03-04 Mon>
*** TODO fix flyspell bindings
<2019-03-04 Mon>
*** MAYBE fix modeline setup for message buffers
<2019-03-03 Sun>
Thsi might already work
*** DONE better closing of straight-x-fetch-all
<2019-03-03 Sun>
*** TODO better org-mode dwim keys
<2019-03-03 Sun>
*** DONE BUT better eyebrowse navigation
<2019-03-03 Sun>
dwim keys, =C-a c= without projectile
<2019-03-27 Wed>
=C-a c= now does eyebrowse-buffer
*** DONE add key-lambda
<2019-03-03 Sun>
Maybe also rename =key-fun= -> =key-fun=.
*** TODO make use-config more useful
<2019-03-03 Sun>
Options:
+ cl-defmacro style
+ nested requirements
+ el-patch integration
+ advice
+ error handling (use-package)
  + use-package-verbose?
+ configuration after hooks
*** DONE BUT improve undo situation
<2019-02-28 Thu>
undo-propose, still needs improvements, undohist, general-simulate
<2019-03-26 Tue>
*** DONE BUT fix ispell error
<2019-02-28 Thu>
Hacky solution -> call once without errors
*** TODO configure shackle
<2019-02-28 Thu>
*** DONE add help support to counsel-M-x
<2019-02-28 Thu>
*** TODO incorporate prescient.el
<2019-02-26 Tue>
*** MAYBE switch away from evil-mode
<2019-02-26 Tue>
Hydra or transient are compelling, less intrusive alternatives.
** Done                                                             :ARCHIVE:
*** HALTING retire "Done" for now
<2019-03-27 Wed>
This does not make too much sense. I should instead focus on writing sensible commit messages.
*** DONE various org-related refactoring
<2019-03-27 Wed>
*** DONE various rust changes
<2019-03-27 Wed>
Patch cargo, remove setup hook, add flycheck
*** DONE new undo system
<2019-03-27 Wed>
undo-propose
<2019-03-27 Wed>
*** DONE reorganize package management section
<2019-03-27 Wed>
Also add customize
*** DONE fix org-return keybindings
<2019-03-03 Sun>
*** DONE add elfeed + configurations
<2019-03-03 Sun>
*** DONE add org-download
<2019-03-03 Sun>
*** DONE rebind dired =f= to find-file
<2019-03-03 Sun>
*** DONE various smaller changes
<2019-03-03 Sun>
**** make disable-all-themes interactive
**** defer visual-fill-collumn
**** error messages with command name prefix
*** DONE BUT refactor operate-on-number
<2019-03-03 Sun>
Decide what needs to be done about "+" prefix
*** DONE add help support to counsel
<2019-03-03 Sun>
closes [[add help support to counsel-M-x]]
*** DONE fix evil escape in minibuffer
<2019-03-03 Sun>
*** DONE BUT update dashboard config
<2019-03-03 Sun>
*** DONE refactor next-prev buffer
<2019-03-03 Sun>
*** DONE fix straight org mode
<2019-03-03 Sun>
The snippet from the README only works when loaded from an external file.
*** DOING improve lispy + evil
*** DONE misc evil fixes
<2019-02-27 Wed>
=evil-want-*= in init
=Y= to eol
*** DONE change ntangle to accomodate global install
<2019-02-27 Wed>
*** DONE add nix directory
<2019-02-27 Wed>
Currently contains ntangle expression
*** DONE various ad-hoc-env improvements
<2019-02-27 Wed>
The directory structure is now tracked by git
*** DONE fix previous/next-buffer regression
<2019-02-27 Wed>
Something or other seems to have broken the structure of said commands
*** DONE replace operate-on-number
<2019-02-27 Wed>
Operate-on-number is complex and can mess up mathematical formatting (eg. LaTeX), so I have replaced it with my own home-cooked solution
*** DONE init changelog
<2019-02-26 Tue>
* End

I'm pretty sure putting this here actually makes no difference for my setup but it seem to be tradition to have it. 

#+begin_src elisp
(provide 'init)
#+end_src

** Footnotes
[fn:dotfiles] Why? [[https://www.anishathalye.com/2014/08/03/managing-your-dotfiles/]]
[fn:extensions] extensions, packages, collections of elisp code, ...
[fn:org-hack] some more context can be found [[https://github.com/raxod502/straight.el#installing-org-with-straightel][here]]
[fn:use-straight] 't' in this case may also be replaced with a symbolic package name or any valid straight.el recipie
[fn:because-vc] because of VC tracking, but this should not limit refactoring
[fn:always-use] this could be changed by always using use-package
[fn:evil-where] evil might sound like a prime candidate for the =Editing= section, but because it also provides utilities like a command prompt and global keybinds, I choose to put it unter =Integration=
[fn:dired-where] while dired is technically used to find files, it is flexible enough to warrant being but under =Misc=
